<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>进程&amp;线程</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="889ffe14-b9e0-471b-b381-08748ce1c4a4" class="page sans"><header><h1 class="page-title"><mark class="highlight-red">进程&amp;线程</mark></h1></header><div class="page-body"><ul id="652ec1fd-753e-4b22-b137-21190625e1dc" class="toggle"><li><details open=""><summary>进程(process)</summary><ul id="2aff6480-1420-44a7-850b-62a808791be2" class="toggle"><li><details open=""><summary>定义</summary><ul id="53a2d163-e557-4fbc-9fd4-295ed722f4ef" class="toggle"><li><details open=""><summary><mark class="highlight-red">进程是程序在操作系统中的一次执行过程</mark>。资源（包括内存、打开的文件等）分配的单位</summary></details></li></ul></details></li></ul><ul id="5444e656-ba1d-4738-ab4d-f1865e896ebb" class="toggle"><li><details open=""><summary>用什么描述进程</summary><ul id="c06199ae-163f-4c3b-ac83-c89e623ca709" class="toggle"><li><details open=""><summary>进程控制块（process control block，PCB）</summary><ul id="ceea3351-219a-4bfa-90d6-5befa634dea3" class="toggle"><li><details open=""><summary>PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</summary></details></li></ul><ul id="28fb1b16-d196-4522-95ac-576634189e50" class="toggle"><li><details open=""><summary>PCB（结构）如何组织</summary><ul id="99f306c9-8309-4975-bb21-7e44e608a0cc" class="toggle"><li><details open=""><summary><mark class="highlight-red">链表</mark>的方式进行组织，把<strong>具有相同状态的进程链在一起，组成各种</strong><mark class="highlight-red"><strong>队列</strong></mark>。</summary></details></li></ul><ul id="a0590aeb-ef3a-441c-ad32-4802490856a3" class="toggle"><li><details open=""><summary>包含信息 &amp; 如何查看</summary><ul id="61548b1e-01cb-4ab5-8ef7-dc08152c1f39" class="toggle"><li><details open=""><summary><strong>进程描述信息：</strong></summary><ul id="ded8a356-6b9a-44d3-9b61-57a036ece015" class="bulleted-list"><li style="list-style-type:disc">进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li></ul><ul id="9f624041-4368-422c-970c-b4c63105377b" class="bulleted-list"><li style="list-style-type:disc">用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul></details></li></ul><ul id="c431052f-7e57-4af6-877a-ef5afab310f4" class="toggle"><li><details open=""><summary><strong>进程控制和管理信息：</strong></summary><ul id="bc6b3fc7-f978-4e75-aebc-e8dc61dcda78" class="bulleted-list"><li style="list-style-type:disc">进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li></ul><ul id="ca4659e2-aa78-4d19-b079-c44664e338db" class="bulleted-list"><li style="list-style-type:disc">进程优先级：进程抢占 CPU 时的优先级；</li></ul></details></li></ul><ul id="09c2063e-7e86-44c0-a695-361f4bc0cb97" class="toggle"><li><details open=""><summary><strong>资源分配清单：</strong></summary><ul id="b0d81460-7fd5-40f9-8e72-47e490f1246b" class="bulleted-list"><li style="list-style-type:disc">有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li></ul></details></li></ul><ul id="82a0c81d-c133-47d4-aed0-ce04ff4eee3a" class="toggle"><li><details open=""><summary><strong>CPU 相关信息：</strong></summary><ul id="d73d8251-2aa7-4f03-b48f-482570068e54" class="bulleted-list"><li style="list-style-type:disc">CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul></details></li></ul><ul id="187f51b2-cb9e-4246-ba9f-fa84b7f27125" class="toggle"><li><details open=""><summary>l<a href="https://blog.csdn.net/wojiaopanpan/article/details/7286430">inux : ps命令是Process Status的缩写</a></summary><p id="45319740-acde-43d3-b185-8d21e966bec1" class="">a 显示所有进程 相当于all</p><p id="3390146a-145c-468e-9071-f030cd9f4734" class="">u 有这个参数会显示“User”这个信息</p><p id="00a9c5e8-f9a1-4248-acdc-7c3dcdb3138a" class="">x 显示所有程序，不以终端机来划分</p></details></li></ul></details></li></ul><ul id="6774da74-1275-4489-81ba-83f2f9db90c8" class="toggle"><li><details open=""><summary><strong>就绪队列</strong></summary></details></li></ul><ul id="a28193d3-fd5d-40c9-9bf4-5a4f9def199c" class="toggle"><li><details open=""><summary><strong>阻塞队列</strong></summary></details></li></ul></details></li></ul><ul id="f451e4c7-0015-4023-adaa-cc976cb63a80" class="toggle"><li><details open=""><summary>linux中的PCB是一个叫做task_struct的东西</summary><p id="3dc98fe2-fa2c-4234-94f4-080b7ed9278a" class="">进程的每个时刻都在这一小部分物理内存上进行操作。其基本模型是这样的：</p><figure id="ecc9f1af-0e26-4078-bb0e-ee956b2dbb02" class="image"><a href="https://img-blog.csdn.net/20180330215546818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1emhhbmd6ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><img style="width:672px" src="https://img-blog.csdn.net/20180330215546818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1emhhbmd6ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"/></a></figure><p id="e391aff5-645c-4624-8ed9-0f968718c04a" class="">这样，即能保证进程的独立性（每个进程在物理内存上的位置都不同），又能使每个进程拥有足够的空间。</p></details></li></ul></details></li></ul></details></li></ul><ul id="56a70e5e-bf42-49e8-bd70-9d0abbf94e93" class="toggle"><li><details open=""><summary>有时候面试问为什么叫进程/ 线程？</summary><p id="e9bde5c7-437c-43fd-9099-031e6fc2228d" class="">线程运行的本质其实就是函数的执行，函数的执行总会有一个源头，这个源头就是所谓的入口函数，CPU从入口函数开始执行从而形成一个<mark class="highlight-red">执行流</mark>，<mark class="highlight-red">只不过我们人为的给执行流起一个名字</mark>，这个名字就叫线程。</p></details></li></ul></details></li></ul><ul id="3ec2e7c7-c94e-46f4-a3c8-181eec110053" class="toggle"><li><details open=""><summary>线程(thread)</summary><ul id="c5910a72-1a0c-4f65-a7e9-e106803e3df1" class="toggle"><li><details open=""><summary>定义：</summary><ul id="d089ce3d-e673-434d-871b-71680a36968c" class="toggle"><li><details open=""><summary>线程是进程当中的一条执行流程。同一进程间的线程可以并发运行且共享相同的地址空间。<a href="https://huanghantao.github.io/2018/01/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%98%AFCPU%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/index.html">是 CPU 调度的单位</a></summary></details></li></ul><ul id="4dbd0bb5-17b1-4a26-b13a-ca20da438022" class="toggle"><li><details open=""><summary>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的<mark class="highlight-red">寄存器和栈</mark>，这样可以确保线程的控制流是相对独立的。</summary><figure id="b7380965-5de4-492b-bc81-c6768dbb182f" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83MTA0MjM2NC00OGE3LTRlMGQtOWRhZi1kMjQyNzYwM2U1MDcucG5n?x-oss-process=image/format,png"><img style="width:432px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83MTA0MjM2NC00OGE3LTRlMGQtOWRhZi1kMjQyNzYwM2U1MDcucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul></details></li></ul><ul id="6f0c9efc-67be-4d76-bf63-d5cc1c19c85f" class="toggle"><li><details open=""><summary>线程的优点</summary><ul id="170222d8-b174-414a-b2bf-e0d1bebcac32" class="bulleted-list"><li style="list-style-type:disc">一个进程中可以同时存在多个线程；</li></ul><ul id="bd43fdfe-f976-4cc4-8488-a17f69d20a28" class="bulleted-list"><li style="list-style-type:disc">各个线程之间可以并发执行；</li></ul><ul id="298fb7b9-ff80-4e98-9142-c0df198badcc" class="bulleted-list"><li style="list-style-type:disc">各个线程之间可以共享地址空间和文件等资源；</li></ul></details></li></ul><ul id="6b8ddf65-6268-4fe2-b7a1-5bb604e6855a" class="toggle"><li><details open=""><summary>线程的缺点</summary><ul id="dc5cc59b-30f8-431c-9dee-a97485cd96cc" class="bulleted-list"><li style="list-style-type:disc">当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。</li></ul><p id="3cfe1c83-8360-42c8-8d3e-0df15ac3f869" class="">举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。</p></details></li></ul><ul id="0edf0225-980a-44e5-9410-523a1910885e" class="toggle"><li><details open=""><summary>线程的上下文切换</summary><ul id="af225da3-44d4-4e93-ba35-de5af7b1e1e2" class="toggle"><li><details open=""><summary>背景：</summary><ul id="5d3a318b-33f2-48da-8669-b18a4b25ada4" class="toggle"><li><details open=""><summary>线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。</summary></details></li></ul><ul id="b29f896e-3596-4e4a-94d0-f4f25f5439c1" class="toggle"><li><details open=""><summary>所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。</summary><ul id="6c6e86ed-f86c-47fc-8cf7-9f712ea0ad12" class="bulleted-list"><li style="list-style-type:disc">当进程只有一个线程时，可以认为进程就等于线程；</li></ul><ul id="7bf3d13a-3732-4108-98f1-ec1366958730" class="bulleted-list"><li style="list-style-type:disc">当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；</li></ul></details></li></ul></details></li></ul><ul id="952a9769-07cf-464a-a1f4-70977de47c72" class="bulleted-list"><li style="list-style-type:disc">当两个线程<mark class="highlight-red">不属于同一个进程</mark>，则切换的过程就跟进程上下文切换一样；</li></ul><ul id="c9bc1381-8659-4247-b1c8-d4c429aa1773" class="bulleted-list"><li style="list-style-type:disc"><strong>当两个线程是</strong><mark class="highlight-red"><strong>属于同一个进程</strong></mark><strong>，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul></details></li></ul><ul id="1d8d0d44-958d-48c3-bb43-c771336ad6a7" class="toggle"><li><details open=""><summary>三种线程的实现方式：</summary><ul id="39adf253-fc33-4ec4-9099-9c228683f00b" class="toggle"><li><details open=""><summary><strong>用户线程（</strong><em><strong>User Thread</strong></em><strong>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</summary><ul id="986a9375-00ae-4730-bb76-10e0e892e063" class="toggle"><li><details open=""><summary>用户线程如何理解？</summary><p id="82b598a5-fcb9-481c-b8dd-1f4fd1182e4f" class="">用户线程是基于用户态的线程管理库来实现的，那么<strong>线程控制块（</strong><em><strong>Thread Control Block, TCB</strong></em><strong>）</strong> 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p><p id="3f1d920b-59cd-4672-9527-7eec9ec39966" class="">所以，<strong>用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</strong></p><figure id="495285de-f9b9-42f1-994c-16d0e016ce53" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled.png"><img style="width:1160px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled.png"/></a></figure></details></li></ul><ul id="eee38f86-4853-4143-afa2-6a00ff69e476" class="toggle"><li><details open=""><summary>用户线程<strong>优点</strong>：</summary><ul id="85edba45-4069-4991-a2b8-126079c5f050" class="bulleted-list"><li style="list-style-type:disc">每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li></ul><ul id="266e4339-1ff1-4865-9f43-666da43ad944" class="bulleted-list"><li style="list-style-type:disc">用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li></ul></details></li></ul><ul id="d6c75021-a46d-40b4-81ef-171449bf4099" class="toggle"><li><details open=""><summary>用户线程<strong>缺点</strong>：</summary><ul id="811b30f8-2972-4cea-bb4f-d631ad4276dd" class="bulleted-list"><li style="list-style-type:disc">由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li></ul><ul id="87f81ab4-be95-42d3-9833-9af46a2828e8" class="bulleted-list"><li style="list-style-type:disc">当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</li></ul><ul id="57da9cba-6a45-4600-9b84-9f17e3b04f01" class="bulleted-list"><li style="list-style-type:disc">由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li></ul></details></li></ul></details></li></ul><ul id="a47d83fb-4a7e-4cf5-b85e-d4ac8fea3e00" class="toggle"><li><details open=""><summary><strong>内核线程（</strong><em><strong>Kernel Thread</strong></em><strong>）</strong>：在内核中实现的线程，是由内核管理的线程；</summary><ul id="8ac04bb9-c640-43cf-a9ca-a5c457cb0d01" class="toggle"><li><details open=""><summary>如何理解内核线程</summary><p id="fe2ab33d-0e4b-498b-8ef1-f56cc90f97e7" class=""><strong>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</strong></p><p id="770fdead-230f-4845-b95a-2b49052a6ad6" class="">内核线程的模型，也就类似前面提到的<strong>一对一</strong>的关系，即一个用户线程对应一个内核线程，如下图所示：</p><figure id="3351b4c6-162d-42fe-b06f-7ed9ca649452" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lZmNlZGM5Ny1lYjI4LTRjNTYtOWYzOS1lNGE3YzkwZGZkNDQucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lZmNlZGM5Ny1lYjI4LTRjNTYtOWYzOS1lNGE3YzkwZGZkNDQucG5n?x-oss-process=image/format,png"/></a></figure><p id="1d621b0e-ca7e-478d-946c-73b7bd80fd69" class="">内核线程模型</p></details></li></ul><ul id="11a7e104-8c05-44c0-bb23-961c4b78f40e" class="toggle"><li><details open=""><summary>内核线程的<strong>优点</strong>：</summary><ul id="567a60b2-f884-462d-a3b8-dea7d83c56a2" class="bulleted-list"><li style="list-style-type:disc">在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li></ul><ul id="f1b07afc-b77c-4669-b248-3151f718dc0d" class="bulleted-list"><li style="list-style-type:disc">分配给线程，多线程的进程获得更多的 CPU 运行时间；</li></ul></details></li></ul><ul id="3e31ae08-e611-4ba8-83df-5632c51cef69" class="toggle"><li><details open=""><summary>内核线程的<strong>缺点</strong>：</summary><ul id="d8d866b3-742e-455e-8152-eb2339659174" class="bulleted-list"><li style="list-style-type:disc">在支持内核线程的操作系统中，由内核来维护进程和线程的上下问信息，如 PCB 和 TCB；</li></ul><ul id="09e1bd1a-752b-4e48-8fa1-fcdc062f869e" class="bulleted-list"><li style="list-style-type:disc">线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；</li></ul></details></li></ul></details></li></ul><ul id="d09c8cd6-11ce-4901-8c86-7a1b5d138dfb" class="toggle"><li><details open=""><summary><a href="https://blog.csdn.net/mm_hh/article/details/72587207"><strong>轻量级进程（</strong></a><a href="https://blog.csdn.net/mm_hh/article/details/72587207"><em><strong>LightWeight Process</strong></em></a><a href="https://blog.csdn.net/mm_hh/article/details/72587207"><strong>）</strong></a>：在内核中来支持用户线程；</summary><ul id="bd82c102-cd2b-4032-882f-bc879d6c0e45" class="toggle"><li><details open=""><summary>轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。</summary></details></li></ul></details></li></ul></details></li></ul></details></li></ul><ul id="c55dd172-6e11-4987-90fa-e128fbbca400" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">linux 的线程和进程</a></summary><ul id="101212f9-cd48-4929-8248-c0cb3fe4e484" class="toggle"><li><details open=""><summary><a href="https://www.nowcoder.com/discuss/821780?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack">程序加载过程</a></summary><p id="46f345bf-a685-4809-9746-4d01281b8ace" class="">比如我有个c文件，如果os要执行我这个文件，我首先要编译成能读懂的文件，但是指令都是二进制，而我加载到内存中以后，那么此刻我需要开辟一块空间，用来存储我所要执行的资源，这个就叫进程，活着的程序，cpu可以读取他的数据，执行代码块。其实对于Linux来说，进程和线程没有区别，比如我们这里有2个进程共享了一个资源空间，那么linux就会模拟这个进程为线程</p></details></li></ul><p id="01c3c344-76c6-4c4a-b3b5-8c2e8a230ef0" class="">从 Linux 内核的角度来看，并没有把线程和进程区别对待。</p><p id="8e980f9e-09c8-4c20-be2c-e056135ca695" class="">我们知道系统调用<code>fork()</code>可以新建一个子<mark class="highlight-red">进程</mark>，
函数<code>pthread()</code>可以新建一个<mark class="highlight-red">线程</mark>。
<strong>但无论线程还是进程，都是用</strong><code><strong>task_struct</strong></code><strong>结构表示的，唯一的区别就是共享的数据区域不同</strong>。</p><p id="f5f8c50c-5762-4ac7-aa09-c3d49530935d" class="">在Linux中每一个进程都是由task_struct结构体来实现的，轻量级进程也就是我们所说的线程它也是一个task_struct结构体实现，当一个程序运行时，操作系用会给这个进程分进程虚拟地址空间，而一个进程中可能存在多个线程来完成不同的事情，把线程的task_struct加载到一个双端队列上从而让CPU去进行调度。</p><p id="4f0eaec9-15dd-4fce-8a34-a13b64fb18d8" class="">换句话说，线程看起来跟进程没有区别，只是<mark class="highlight-red">线程的某些数据区域和其父进程是共享的</mark>，而<mark class="highlight-red">子进程是拷贝副本</mark>，而不是共享。就比如说，<code>mm</code>结构和<code>files</code>结构在线程中都是共享的，我画两张图你就明白了：</p><figure id="73fa8a12-dc45-4b61-94f3-13de7109ca48" class="image"><a href="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEZbbic0diawibWHE9EoMFmX8qrR0Sam0XhbY019OP12fwno0aKESYicosDibAbDlhNJ2B1KFq7yvlxKhA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><img style="width:480px" src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEZbbic0diawibWHE9EoMFmX8qrR0Sam0XhbY019OP12fwno0aKESYicosDibAbDlhNJ2B1KFq7yvlxKhA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"/></a></figure><figure id="7abb476e-6455-488c-b799-7675eb5815dc" class="image"><a href="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEZbbic0diawibWHE9EoMFmX8qlOLgJw9xF5oovWGIs3ZDDXtiblhAFDdyKAIwntLbjNwZ5xA52KP4XTg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><img style="width:480px" src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdEZbbic0diawibWHE9EoMFmX8qlOLgJw9xF5oovWGIs3ZDDXtiblhAFDdyKAIwntLbjNwZ5xA52KP4XTg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"/></a></figure><figure id="82d51b19-b81b-47a9-b394-d4064160b3bc" class="image"><a href="https://img-blog.csdn.net/20180330215546818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1emhhbmd6ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><img style="width:672px" src="https://img-blog.csdn.net/20180330215546818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1emhhbmd6ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"/></a></figure></details></li></ul><ul id="a370be37-c4ff-4095-a04b-bfd1e63895ce" class="toggle"><li><details open=""><summary><mark class="highlight-red">父进程子进程 （是进程）</mark></summary></details></li></ul><ul id="6dd242a4-a2ec-46fe-b804-ac7979c118ea" class="toggle"><li><details open=""><summary><a href="https://www.cnblogs.com/Survivalist/p/11527949.html">协程 Coroutine</a></summary><p id="71a94fd0-25e2-4caf-97bb-875fab06b466" class=""><a href="https://zhuanlan.zhihu.com/p/172471249">ref2</a></p><ul id="238c272c-c9b0-41a5-b40d-f4d526c887a0" class="toggle"><li><details open=""><summary>定义</summary><p id="5ba7ca78-f995-465d-9de2-06c90b1b4276" class="">协程 = 微线程，比线程更加轻量级的存在</p><p id="3821568f-44d4-41f5-bb49-15bb8786d07f" class="">这种由程序员自己写程序来管理的轻量级线程叫做『<mark class="highlight-red">用户空间线程</mark>』，具有对内核来说不可见的特性。</p><figure id="5df1f247-8f53-4e6f-ad72-9e6c1d25bc6e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%201.png"><img style="width:724px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%201.png"/></a></figure><p id="5091a96b-4d9a-4c36-8be7-5d28a443470c" class="">协程就是<mark class="highlight-red">子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。</mark>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。 为什么</p></details></li></ul><ul id="411fc4d9-7986-4f1a-8b27-e7093ed66d79" class="toggle"><li><details open=""><summary>意义 - 什么时候用</summary><ul id="797161b5-b107-4d41-a4b2-8bda46046c65" class="toggle"><li><details open=""><summary>减少开销（空间 + 时间）</summary><p id="1acdce40-21ab-4061-b8d2-a6e31165024c" class="">我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p><figure id="9a81101d-3983-497f-a271-4656b9b03797" class="image"><a href="https://pic1.zhimg.com/v2-edafcd23346b92693d70da0032486914_b.jpg"><img style="width:528px" src="https://pic1.zhimg.com/v2-edafcd23346b92693d70da0032486914_b.jpg"/></a></figure><p id="69ab59dc-e713-41c6-a92b-2179dc759715" class="">协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过</strong><mark class="highlight-red"><strong>分时复用</strong></mark><strong>的方式运行多个协程</strong>，而且<mark class="highlight-red">协程的切换在用户态完成</mark>，切换的代价比线程从用户态到内核态的代价小很多。（golang用的多）</p><figure id="f70ace4f-27be-426a-824f-c9781cbe8338" class="image"><a href="https://pic3.zhimg.com/v2-f4fb2dea86d909ed60498b7021d0fe66_b.jpg"><img style="width:576px" src="https://pic3.zhimg.com/v2-f4fb2dea86d909ed60498b7021d0fe66_b.jpg"/></a></figure><p id="72cdeefc-09e3-402d-be39-1fcc16c4e8bf" class="">回到上面的问题，我们只需要启动100个线程，每个线程上运行100个协程，这样不仅减少了线程切换开销，而且还能够同时处理10000个读取数据库的任务，很好的解决了上述任务。</p></details></li></ul></details></li></ul><ul id="4872b4b6-1b7d-4051-89a1-7db796422860" class="toggle"><li><details open=""><summary>(原理)底层实现?  怎么使用协程？（为什么代价更小）</summary><p id="bc97fbea-bc5f-454a-8b21-79fd78084a16" class="">协程进行中断跳转时将函数的<a href="https://zhuanlan.zhihu.com/p/187339012"><mark class="highlight-red">上下文</mark></a><mark class="highlight-red">存放在其他位置中</mark>，而<mark class="highlight-red">不是存放在函数堆栈里</mark>，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p></details></li></ul><ul id="d324fb9d-81cf-4844-98e0-158387f4970b" class="toggle"><li><details open=""><summary>协程 vs 线程  <a href="https://blog.csdn.net/weixin_49345590/article/details/112183455">ref</a></summary><div id="c0754ca1-df59-4768-82e6-0c8be445dcb6" class="collection-content"><h4 class="collection-title"></h4><table class="collection-content"><thead><tr><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesTitle"><path d="M7.73943662,8.6971831 C7.77640845,8.7834507 7.81338028,8.8943662 7.81338028,9.00528169 C7.81338028,9.49823944 7.40669014,9.89260563 6.91373239,9.89260563 C6.53169014,9.89260563 6.19894366,9.64612676 6.08802817,9.30105634 L5.75528169,8.33978873 L2.05809859,8.33978873 L1.72535211,9.30105634 C1.61443662,9.64612676 1.2693662,9.89260563 0.887323944,9.89260563 C0.394366197,9.89260563 0,9.49823944 0,9.00528169 C0,8.8943662 0.0246478873,8.7834507 0.0616197183,8.6971831 L2.46478873,2.48591549 C2.68661972,1.90669014 3.24119718,1.5 3.90669014,1.5 C4.55985915,1.5 5.12676056,1.90669014 5.34859155,2.48591549 L7.73943662,8.6971831 Z M2.60035211,6.82394366 L5.21302817,6.82394366 L3.90669014,3.10211268 L2.60035211,6.82394366 Z M11.3996479,3.70598592 C12.7552817,3.70598592 14,4.24823944 14,5.96126761 L14,9.07922535 C14,9.52288732 13.6549296,9.89260563 13.2112676,9.89260563 C12.8169014,9.89260563 12.471831,9.59683099 12.4225352,9.19014085 C12.028169,9.6584507 11.3257042,9.95422535 10.5492958,9.95422535 C9.60035211,9.95422535 8.47887324,9.31338028 8.47887324,7.98239437 C8.47887324,6.58978873 9.60035211,6.08450704 10.5492958,6.08450704 C11.3380282,6.08450704 12.040493,6.33098592 12.4348592,6.81161972 L12.4348592,5.98591549 C12.4348592,5.38204225 11.9172535,4.98767606 11.1285211,4.98767606 C10.6602113,4.98767606 10.2411972,5.11091549 9.80985915,5.38204225 C9.72359155,5.43133803 9.61267606,5.46830986 9.50176056,5.46830986 C9.18133803,5.46830986 8.91021127,5.1971831 8.91021127,4.86443662 C8.91021127,4.64260563 9.0334507,4.44542254 9.19366197,4.34683099 C9.87147887,3.90316901 10.6232394,3.70598592 11.3996479,3.70598592 Z M11.1778169,8.8943662 C11.6830986,8.8943662 12.1760563,8.72183099 12.4348592,8.37676056 L12.4348592,7.63732394 C12.1760563,7.29225352 11.6830986,7.11971831 11.1778169,7.11971831 C10.5616197,7.11971831 10.056338,7.45246479 10.056338,8.0193662 C10.056338,8.57394366 10.5616197,8.8943662 11.1778169,8.8943662 Z M0.65625,11.125 L13.34375,11.125 C13.7061869,11.125 14,11.4188131 14,11.78125 C14,12.1436869 13.7061869,12.4375 13.34375,12.4375 L0.65625,12.4375 C0.293813133,12.4375 4.43857149e-17,12.1436869 0,11.78125 C-4.43857149e-17,11.4188131 0.293813133,11.125 0.65625,11.125 Z"></path></svg></span>比较项</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>线程</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>协程</th></tr></thead><tbody><tr id="234c878b-f746-4366-ad3f-c4724fb851ba"><td class="cell-title"><a href="https://www.notion.so/234c878bf7464366ad3fc4724fb851ba">占用资源</a></td><td class="cell-=T_X">初始单位为1MB,固定不可变</td><td class="cell-Cr~a">初始一般为 2KB，可随需要而增大</td></tr><tr id="a90cf6b4-58c9-4b3e-b9aa-531351163e5e"><td class="cell-title"><a href="https://www.notion.so/a90cf6b458c94b3eb9aa531351163e5e">调度所属</a></td><td class="cell-=T_X">由 OS 的内核完成</td><td class="cell-Cr~a">由用户完成</td></tr><tr id="ca91d1b6-34e8-44d3-890c-42143344a3bc"><td class="cell-title"><a href="https://www.notion.so/ca91d1b634e844d3890c42143344a3bc">切换开销</a></td><td class="cell-=T_X">涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等</td><td class="cell-Cr~a">只有三个寄存器的值修改 - PC / SP / DX.</td></tr><tr id="cb79682a-ca17-4709-a4c2-1eff106a6453"><td class="cell-title"><a href="https://www.notion.so/cb79682aca174709a4c21eff106a6453">性能问题</a></td><td class="cell-=T_X">资源占用太高，频繁创建销毁会带来严重的性能问题</td><td class="cell-Cr~a">资源占用小,不会带来严重的性能问题</td></tr><tr id="8a666483-8973-4081-866a-0f308684d396"><td class="cell-title"><a href="https://www.notion.so/8a66648389734081866a0f308684d396">数据同步</a></td><td class="cell-=T_X">需要用锁等机制确保数据的一直性和可见性</td><td class="cell-Cr~a">不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td></tr><tr id="4ac4c213-7db5-4327-bbdd-75746fbbf9c2"><td class="cell-title"><a href="https://www.notion.so/4ac4c2137db54327bbdd75746fbbf9c2">Untitled</a></td><td class="cell-=T_X"></td><td class="cell-Cr~a"></td></tr></tbody></table></div></details></li></ul></details></li></ul><ul id="623d1489-c670-42bd-9871-93c4f00222e2" class="toggle"><li><details open=""><summary><mark class="highlight-orange_background">线程进程协程——比较：（</mark><mark class="highlight-red">面试如果要简单讲一下，讲这个</mark><mark class="highlight-orange_background">）</mark></summary><p id="7d183351-b2ee-4109-aa6f-f65167cca32a" class="">究其根本来说，他们都只是一个单位，不同的单位对应不同的操作，适用于不同的环境</p><table id="e5b2e8db-74a3-489a-bd12-79821e56ef7c" class="simple-table"><thead><tr id="779d99aa-12d5-4187-ac84-c07c7ad0f90b"><th id="_Hkf" class="simple-table-header"></th><th id="bmJ&gt;" class="simple-table-header">进程</th><th id="sYX~" class="simple-table-header">线程</th><th id="Fs;v" class="simple-table-header">协程</th></tr></thead><tbody><tr id="a0e23d33-d473-47a8-aea0-645b9279f36d"><td id="_Hkf">定义</td><td id="bmJ&gt;">进程是程序在操作系统中的一次执行过程。
是<mark class="highlight-red">资源</mark>（包括内存、打开的文件等）<mark class="highlight-red">分配的单位</mark></td><td id="sYX~">线程是进程当中的一条执行流程。
线程是执行调度
是<mark class="highlight-red"> CPU 调度的单位</mark></td><td id="Fs;v">协程 = 微线程，比线程更加轻量级的存在</td></tr><tr id="ed5dd385-b52e-4405-a569-09b12479e934"><td id="_Hkf">特点/不同点（内存）</td><td id="bmJ&gt;">进程拥有一个完整的资源平台</td><td id="sYX~">线程是进程当中的一条执行流程。
线程只独享必不可少的资源，如寄存器和栈；（所以堆是共享的？）</td><td id="Fs;v"><mark class="highlight-red">用户空间线程,</mark>对内核来说不可见的特性</td></tr><tr id="bb592d77-1575-4f75-8c0b-4772ef2e6d43"><td id="_Hkf">调度&amp;<a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">上下文切换开销</a></td><td id="bmJ&gt;"><mark class="highlight-red">发生在内核
</mark>所有资源</td><td id="sYX~"><mark class="highlight-red">发生在内核
</mark>涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等	</td><td id="Fs;v">用户完成
只有三个寄存器的值修改 - PC / SP / DX.

(栈指针SP，调度挂起的数据DX，PC)</td></tr><tr id="d6b1c844-b007-4676-937d-6d48c2f32692"><td id="_Hkf">关系</td><td id="bmJ&gt;">最大</td><td id="sYX~">———————-→</td><td id="Fs;v">最小</td></tr><tr id="56ad06ab-d0ce-4dea-8e8a-fd4c1757f27d"><td id="_Hkf">应用场景</td><td id="bmJ&gt;"></td><td id="sYX~"> I/O 频繁</td><td id="Fs;v">I/O 更频繁</td></tr><tr id="0a76894d-f89a-4e78-b0c2-29ab2b6b9fb2"><td id="_Hkf">通信机制</td><td id="bmJ&gt;"></td><td id="sYX~"></td><td id="Fs;v"></td></tr><tr id="6f1bdae4-60d3-426f-a403-024f86c13547"><td id="_Hkf">性能</td><td id="bmJ&gt;">（进程占优）通过增加CPU，就可以容易扩充性能
多进程可以尽量减少线程加锁/解锁的影响，极大提高性能</td><td id="sYX~">线程受限内存，且到达一定线程数后再增加cpu也无法提升性能</td><td id="Fs;v"></td></tr><tr id="a15e962f-78af-49ca-beab-ef219819d5ed"><td id="_Hkf">。。。</td><td id="bmJ&gt;"></td><td id="sYX~"></td><td id="Fs;v">c++20</td></tr></tbody></table><figure id="db87ba85-b486-428f-8e4f-8ee8b3fa7aa4" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%202.png"><img style="width:520px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%202.png"/></a></figure><ul id="184cc512-4731-47d1-829c-3702de198c48" class="toggle"><li><details open=""><summary>定义：</summary><p id="f003f245-1521-4481-8634-e099df5ead11" class="">进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</p></details></li></ul><p id="ed480a82-0921-40a1-9b57-d11d966f4bbb" class="">
</p><ul id="c5edc3e9-2f45-4d59-8cdd-4313db973e11" class="toggle"><li><details open=""><summary>关系：</summary><p id="7941154a-3fdc-4683-9161-ccd797a4df84" class="">线程是进程当中的一条执行流程。</p><p id="1177a35a-90c7-4bb3-b8d6-788dce54797f" class="">进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；（所以堆是共享的？）</p></details></li></ul><ul id="4fbc01b2-fc42-422a-b720-5ab1fd8dddb4" class="toggle"><li><details open=""><summary>特点：</summary><p id="d0948a2e-a58d-4e8b-90cc-eeaa962ab757" class="">线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</p><ul id="0c46435c-d6ca-42e9-9d09-db76c282c043" class="toggle"><li><details open=""><summary>线程能减少并发执行的时间和空间开销；</summary><ul id="bd38eacf-74ce-47dd-9722-337d6d2f8845" class="bulleted-list"><li style="list-style-type:disc">线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li></ul><ul id="057342fa-bbac-4c92-ae24-ecc9e257de24" class="bulleted-list"><li style="list-style-type:disc">线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li></ul><ul id="732e1567-9404-4f4b-a94c-3861df1f3503" class="bulleted-list"><li style="list-style-type:disc">同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），<mark class="highlight-red">这意味着同一个进程的线程都具有同一个页表</mark>，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li></ul><ul id="24f8c667-bdc9-4b79-a8aa-3a6995ec3cf6" class="bulleted-list"><li style="list-style-type:disc">由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；<p id="5213b448-521d-4da5-a9e0-8f2233c16bb2" class="">所以，线程比进程不管是时间效率，还是空间效率都要高。</p></li></ul></details></li></ul></details></li></ul><ul id="0cdbd081-da87-4424-8ce2-6e9e254695d0" class="toggle"><li><details open=""><summary>内存：<a href="https://cloud.tencent.com/developer/article/1768025">共享&amp;独有</a>资源（讲的太好）</summary><p id="c12375ef-8b65-4f13-9f79-a04971506a89" class="">
</p></details></li></ul></details></li></ul><p id="afe5455c-0d90-4f12-8d81-0355badf5d8f" class="">
</p><p id="2622ae99-6c47-4a7b-90fd-fd322c97e0a9" class="">
</p><ul id="81bf3147-1b6c-4ab6-9678-2dabc3f08198" class="toggle"><li><details open=""><summary><a href="https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html">线程安全</a> - 本质是指内存的安全</summary><ul id="4a393583-0f1f-4760-9e76-b9f18200df4f" class="toggle"><li><details open=""><summary>含义 - what</summary><ul id="5d815ef2-4743-42d2-9cd3-3ec0d4c52dff" class="toggle"><li><details open=""><summary>pre</summary><p id="64f8f4be-f0bc-4187-a798-98e5beaf0df4" class="">线程通信是同一个进程的多个子线程之间的通信。因为所有线程共享一个进程资源，所以就存在线程安全问题。所以如果有面试题目问你什么是线程安全问题，你可以回答</p></details></li></ul><p id="5c1d3588-801d-42fd-8e55-3bd1d19c2e90" class="">多个<mark class="highlight-red">线程同时共享一个全局变量或者静态变量</mark>，做<mark class="highlight-red">写操作时会发生数据冲突</mark>，也就是线程安全问题。</p><p id="c7cc4d7b-f1d2-4bd2-9ea2-d47577bc5449" class="">在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在<mark class="highlight-red">被意外修改</mark>的风险。</p><p id="2578e679-cc8e-4772-91da-216b37975b02" class="">“<mark class="highlight-red">线程安全”也不是指线程的安全，而是指内存的安全。</mark>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p></details></li></ul><ul id="8df8cb0a-bec0-487e-afb2-dae4fb7ba72e" class="toggle"><li><details open=""><summary>解决方案：</summary><ul id="7090612a-27a9-44c9-b44a-4a39d43928f5" class="toggle"><li><details open=""><summary>数据隔离 放在私人区域 栈</summary></details></li></ul><ul id="2303e617-45dd-4588-ab7a-fdc7c8d79853" class="toggle"><li><details open=""><summary>公共区域 只读操作</summary></details></li></ul><ul id="6b6f0334-4035-4afb-a00c-85f9e1f68ee0" class="toggle"><li><details open=""><summary>同步</summary></details></li></ul></details></li></ul><ul id="cd944963-02ed-4ee6-b575-0539d51db6da" class="toggle"><li><details open=""><summary>程序在一个单核cpu运行多线程程序，会有线程安全问题吗</summary><p id="c4457233-9499-4e16-b259-c6ad309872ef" class="">我认为是会的，因为同一进程的线程之间 共享部分区域内存，这部分其实是需要上锁</p></details></li></ul></details></li></ul><ul id="b4a7024d-e720-442a-a3a2-a416a071a89e" class="toggle"><li><details open=""><summary>线程池→ <a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">socket</a></summary></details></li></ul><p id="11abb7f3-d072-443e-8390-6e1c4b7e3c05" class="">
</p><p id="31e53bf7-ff95-493e-9934-948b2645655f" class="block-color-orange_background">内存 &amp; 状态切换</p><ul id="7fbaab07-09e1-4f8d-b9f4-73e16e56d7df" class="toggle"><li><details open=""><summary><mark class="highlight-red"><a href="https://zhuanlan.zhihu.com/p/52845869">上下文切换</a></mark></summary><p id="c489d3b5-ea6b-40ae-95e3-a16d9d7be68c" class=""><a href="https://muyuuuu.github.io/2021/04/16/CPU-context-switch/">ref1 讲的不错</a></p><ul id="9443ef44-735f-4e2f-b842-1f740a7ec535" class="toggle"><li><details open=""><summary>上下文切换种类</summary><ul id="46ec52be-7a79-439f-9a9f-525684bec828" class="toggle"><li><details open=""><summary>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。</summary></details></li></ul><ul id="d83115bd-67b7-4014-9c3c-c62abe2fe87f" class="toggle"><li><details open=""><summary>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：<mark class="highlight-red"><strong>进程上下文切换、线程上下文切换和中断上下文切换</strong></mark><strong><mark class="highlight-teal_background">。（看情况根据不同单位）</mark></strong></summary></details></li></ul></details></li></ul><ul id="50903ff6-11ee-4f03-b9a0-63063199eed8" class="toggle"><li><details open=""><summary><mark class="highlight-red">系统调用</mark>发生了几次CPU上下文切换</summary><p id="a2b5857a-a530-4160-b7a6-19ed90913c03" class="">从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><ul id="967e7f31-d397-428b-862d-8058b8aa014a" class="toggle"><li><details open=""><summary>在这个过程中就发生了 CPU 上下文切换，<mark class="highlight-red">整个过程</mark>是这样的：</summary><p id="b187779b-8f60-49b7-8600-c3f7af59faae" class="">1、<mark class="highlight-red">保存 CPU 寄存器里原来用户态的指令位</mark></p><p id="e570dade-8573-427e-bd5f-749da0d3de84" class="">2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</p><p id="c41e6ba7-2f26-4d9e-9d3e-6a74b48e5063" class="">3、跳转到内核态运行内核任务。</p><p id="3bcdf6e6-87fe-4877-ad51-a90c4c3a5bf7" class="">4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p></details></li></ul><ul id="53d95135-6922-4993-a379-04022866edab" class="toggle"><li><details open=""><summary>所以，<strong>一次系统调用的过程，其实是</strong><mark class="highlight-red"><strong>发生了两次 CPU 上下文切换</strong></mark>。（<mark class="highlight-red">用户态-内核态-用户态</mark>）</summary></details></li></ul><p id="0e9cc6dd-8d1a-4827-b46c-8b0fc7ecee44" class="">不过，需要注意的是，<strong>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。这跟我们通常所说的进程上下文切换是不一样的：<mark class="highlight-red"><strong>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。</strong></mark></p><p id="03172a81-614e-4c6d-bc84-6cb9c8451b4d" class="">所以，<strong>系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换</strong>。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</p></details></li></ul><ul id="5dc8c3d6-ba8d-401d-bdb8-66d48c1a91d8" class="toggle"><li><details open=""><summary><mark class="highlight-red">进程</mark>的上下文切换</summary><ul id="777247ce-5ec8-4a72-9521-d842c9063f0e" class="toggle"><li><details open=""><summary>各个进程之间是共享 CPU 的，在不同的时候进程之间需要切换，让<mark class="highlight-red">不同的进程</mark>可以<mark class="highlight-red">在 CPU 上执行</mark>，那么这个<mark class="highlight-red"><strong>一个进程切换到另一个进程运行</strong></mark><strong>，称为进程的上下文切换。</strong></summary></details></li></ul><ul id="fd3aa549-4f86-48d8-a1ff-b2327ef37e58" class="toggle"><li><details open=""><summary><mark class="highlight-red">切换的到底是什么</mark></summary><p id="ae20873f-2141-46d9-9207-5f9f7a91ca2c" class="">意味着内存区域所有数据，置换整个内存空间</p><ul id="1b1c5467-2a26-4ed4-a17e-9fdcdc33253d" class="toggle"><li><details open=""><summary><mark class="highlight-red">所以是虚拟内存中的所有资源？</mark></summary></details></li></ul><ul id="5b4f1089-080c-4fec-9e44-f2ef21b7daca" class="toggle"><li><details open=""><summary>不仅包含了虚拟内存、栈、全局变量等<mark class="highlight-red">用户空间</mark>的资源，还包括了内核堆栈、寄存器等<mark class="highlight-red">内核空间</mark>的资源。</summary></details></li></ul><ul id="f5a24576-0535-4d72-8886-dcad8514e464" class="toggle"><li><details open=""><summary>进程是由内核管理和调度的，所以进程的切换只能发生在内核态<mark class="highlight-red">。</mark></summary></details></li></ul><ul id="4a6961ea-00a9-46c7-9ef0-47612c7df8ef" class="toggle"><li><details open=""><summary>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行</summary><figure id="594f0e97-3298-42bc-9005-bbbc0313b6f7" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YzI4MWM0NC04ZmUzLTQyMzgtOWUyOC00ZDNkMGI1MWI5YWEucG5n?x-oss-process=image/format,png"><img style="width:400px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YzI4MWM0NC04ZmUzLTQyMzgtOWUyOC00ZDNkMGI1MWI5YWEucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul></details></li></ul><ul id="0266098b-87b7-4469-a7d5-cf7b25ad7063" class="toggle"><li><details open=""><summary>发生进程上下文切换的场景</summary><ol type="1" id="6af76333-95f1-4e44-b816-f9a1b923af38" class="numbered-list" start="1"><li>基于<mark class="highlight-red">时间片</mark>的操作系统，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li></ol><ol type="1" id="f8719094-c33f-4b52-a8d7-f213fb35f49f" class="numbered-list" start="2"><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li></ol><ol type="1" id="42b91fb0-31d2-4655-a657-53b65ccc4f06" class="numbered-list" start="3"><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li></ol><ol type="1" id="af6cb866-8079-4157-a391-e49f00a66802" class="numbered-list" start="4"><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li></ol><ol type="1" id="4ba08162-2323-40d6-acb1-56eff24aaf02" class="numbered-list" start="5"><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol></details></li></ul></details></li></ul><ul id="d36b5068-f6b7-49b8-92d2-ec3f6103fb47" class="toggle"><li><details open=""><summary>进程上下文切换跟系统调用有什么区别</summary><p id="3a1c58d5-55f4-480b-b803-b1cab0b0bdce" class="">首先，<strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p id="e1195f38-68dc-4462-9056-7058524d61df" class="">因此，<strong>进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</strong>。</p><p id="9c77963d-5097-402b-a043-8b6895f269da" class="">如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><figure id="250f7e1d-2dff-45ff-a0a6-40a2a19bfe5d" class="image"><a href="https://pic3.zhimg.com/v2-440bb1699b2fa0f0340b38eabcbd7452_b.jpg"><img style="width:672px" src="https://pic3.zhimg.com/v2-440bb1699b2fa0f0340b38eabcbd7452_b.jpg"/></a></figure></details></li></ul><ul id="7e5ed64c-743c-49d8-b72e-0eb84af0e44c" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>线程</strong></mark><strong>上下文切换</strong></summary><p id="0b8654f7-05de-4bec-b614-f2ea256259a4" class="">线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。<mark class="highlight-red">说白了，所谓内核中的任务调度，实际上的调度对象是线程</mark>；而进程只是给线程提供了虚拟内存、全局变量等资源。线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><p id="fa004bb9-ffc8-475e-adc7-b2451f3cd20f" class="">发生线程上下文切换的场景：<div class="indented"><ul id="55f94dc7-a689-4f98-9ce6-bc1765f94aa6" class="bulleted-list"><li style="list-style-type:disc">前后两个线程<mark class="highlight-red">属于不同进程</mark>。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。切换线程，CPU 的各种寄存器都要重新刷一遍，从这个角度而言，你可以把进程和线程当作一种东西，只是共享度不同，其他没区别的。</li></ul><ul id="fd0ae6ba-f7f3-43e4-bb27-51cbfc0a494e" class="bulleted-list"><li style="list-style-type:disc">前后两个线程<mark class="highlight-red">属于同一个进程</mark>。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，内存命中率会高一些，只需要切换线程的私有数据、寄存器等不共享的数据。</li></ul></div></p><p id="bbd09324-f23a-48d2-839d-be8de6683f5d" class="">虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。</p></details></li></ul><ul id="dd1129f8-033f-4e88-97eb-6e0ab8ddf9d5" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>中断</strong></mark><strong>上下文切换</strong></summary><p id="eae14612-fe9f-43f1-bd99-d197728682f9" class="">中断处理程序运行于内核态。中断发生时CPU可能处于内核态（如执行系统调用的过程中）也可能处于用户态（执行应用空间代码）:</p><p id="571a1c1b-8c2a-499b-8f78-55dd3800bb79" class="">
</p><ul id="aeb18df9-2ab7-415e-a1ee-048715d58e71" class="toggle"><li><details open=""><summary>不涉及特权级转换的情况：</summary><ul id="56c06901-7772-4f5f-aab2-27fa3d84de25" class="bulleted-list"><li style="list-style-type:disc">压入寄存器现场、错误代码等</li></ul><ul id="a5c53650-d762-47d0-85e2-cee0c8214e7c" class="bulleted-list"><li style="list-style-type:disc">执行中断处理程序</li></ul><ul id="2d5e5c32-942d-4d23-88e1-cf83ad898066" class="bulleted-list"><li style="list-style-type:disc">恢复寄存器现场</li></ul><p id="40a58dd0-5dad-4750-bd1e-af454edf90e5" class="">可以看到这里并没有发生堆栈的切换——因为本来就运行在内核栈上嘛！中断处理程序借用了应用程序的内核栈。说『借用』是因为进程的内核栈是给进程执行内核空间代码使用的（通常就是系统调用），由于中断并不一定和正在运行的进程有什么关联。</p></details></li></ul><ul id="e225d8ed-af39-43e5-9574-13a20f188d8d" class="toggle"><li><details open=""><summary>但是对于用户态中被中断，有一个用户 <code>-&gt;</code> 内核 <code>-&gt;</code> 用户的切换过程，伴随着相关栈的切换。具体过程：</summary><ul id="b323367b-7bd4-4f9c-9cd1-9cb813478e22" class="bulleted-list"><li style="list-style-type:disc">找到内核栈</li></ul><ul id="4ce9f053-d829-431e-b317-6d6df69bac28" class="bulleted-list"><li style="list-style-type:disc">压入寄存器现场、错误代码</li></ul><ul id="b22e5b61-623b-4274-9dda-619d95edbe84" class="bulleted-list"><li style="list-style-type:disc">转入中断处理程序</li></ul><ul id="c73849d3-8a8f-4b2b-b5bf-b46f7f45180f" class="bulleted-list"><li style="list-style-type:disc">恢复第二步保存的现场</li></ul><ul id="cbfa3421-feab-4059-8d45-8194b172d3ef" class="bulleted-list"><li style="list-style-type:disc">切换换回用户栈</li></ul></details></li></ul><p id="5ae5bdf9-0051-4b2d-960c-c6e5d83658da" class="">为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件，如断电和设备损坏等。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p id="a41ab0a2-b782-446d-830a-89cb2361d055" class="">中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。跟进程上下文不同，中断上下文切换的东西不需要涉及到用户态。所以，<mark class="highlight-red">即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源；只需在内核态记录：</mark>当前进程的寄存器和程序计数器。如喜闻乐见的，硬盘传输文件时突然拔掉硬盘，传输文件进程的虚拟内存、全局变量等用户态资源都没有被保存，相当于白传输了。<del>例子有点生硬。</del></p><p id="7b3cede6-c386-4f5b-9b3b-52bcb9cbf0e0" class="">
</p><p id="ebd7772e-ab32-4ee5-8798-b5b11f4a2a1c" class=""><strong>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p id="f105eee7-839c-48a7-981c-cf5420bf0629" class="">另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p></details></li></ul><p id="b0f4af4f-2414-4d9e-b6be-39b502a628bd" class="">
</p></details></li></ul><ul id="f121bbbc-11a5-4d95-a806-e452bfcc8e24" class="toggle"><li><details open=""><summary><a href="https://www.jianshu.com/p/00a97bac4913">状态变迁</a></summary><ul id="1efb04b4-f2c7-4b0e-9c30-4ea8c1f2dd9d" class="toggle"><li><details open=""><summary>并行 并发</summary><figure id="6c785252-7356-4a10-9466-ca6b93669041" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lMjAzZjJmNy0zMTQ2LTQ5NjMtOWVhMy04ODE4YTg2YjdmNzAucG5n?x-oss-process=image/format,png"><img style="width:336px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lMjAzZjJmNy0zMTQ2LTQ5NjMtOWVhMy04ODE4YTg2YjdmNzAucG5n?x-oss-process=image/format,png"/></a></figure><p id="b4a7b886-0754-4876-96ae-859f7dec17e8" class="">
</p></details></li></ul><ul id="fd0b4fb0-87ed-4786-af1d-a7d80e029043" class="toggle"><li><details open=""><summary><mark class="highlight-red">进\线 三种状态</mark></summary><ul id="ef972136-2901-48e2-aafc-19bb0caa7b79" class="toggle"><li><details open=""><summary>就绪状态ready</summary><p id="d1c982be-0392-4b10-b63b-64cfdc1511b0" class="">可运行，但因为其他进程正在运行而暂停停止</p></details></li></ul><ul id="6431277f-e49c-45e0-9973-9ca0e9cd0ca3" class="toggle"><li><details open=""><summary>运行状态running</summary><p id="ffbc3ad5-7302-4ebf-8278-2367a446736b" class="">该时刻进程占用 CPU</p></details></li></ul><ul id="7b78ac07-37fb-4a27-a83d-97ea8bfa66d1" class="toggle"><li><details open=""><summary>阻塞状态blocked</summary><p id="36e4128c-35f4-458a-9be0-bd73e779bb17" class="">该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行</p></details></li></ul><figure id="f2813ae6-6553-4752-a8e1-8a47603145f5" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8xYTg0M2UxMS0wOTc1LTQzYjQtOGI1ZS1lMTlkMjllODEyNmUucG5n?x-oss-process=image/format,png"><img style="width:672px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8xYTg0M2UxMS0wOTc1LTQzYjQtOGI1ZS1lMTlkMjllODEyNmUucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul><ul id="d68a811a-375f-485d-a3d4-7bee541363da" class="toggle"><li><details open=""><summary>进\线 程另外两个基本状态：</summary><ul id="5d6e69af-7554-4d84-9c89-d388e72218c9" class="bulleted-list"><li style="list-style-type:disc">创建状态（<em>new</em>）：进程正在被创建时的状态；</li></ul><ul id="def50de2-4a6c-4afb-94d6-3abf61dd8007" class="bulleted-list"><li style="list-style-type:disc">结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li></ul></details></li></ul><ul id="27546978-56e0-4904-a8de-9a366e6ee704" class="toggle"><li><details open=""><summary>进\线 程五种状态的变迁</summary><figure id="caf84727-5f27-4513-bb25-184d8d37867f" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lZGJhYjFmNi00YTc1LTRiOTgtYjk1YS1kODBkNzFjYzVkZDkucG5n?x-oss-process=image/format,png"><img style="width:1007px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lZGJhYjFmNi00YTc1LTRiOTgtYjk1YS1kODBkNzFjYzVkZDkucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul><ul id="ed4aa376-e699-45dc-9153-913feaa280af" class="toggle"><li><details open=""><summary>进程的控制（一个进程从开始运行到结束的完整过程（四个过程）</summary><p id="5f96bcb3-bff9-488c-af40-ec2f8bcff1cf" class="">（面经中只问过一次，低频）</p><ul id="f06a602e-d52a-44f8-aad6-bd43886e5dc5" class="toggle"><li><details open=""><summary>创建</summary><ul id="d2f420d9-d41b-47b1-ab7f-ea8aab4a3644" class="bulleted-list"><li style="list-style-type:disc">为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；</li></ul><ul id="ff2a3f09-23a5-48ab-8a34-0c8a2ce73e25" class="bulleted-list"><li style="list-style-type:disc">为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；</li></ul><ul id="9a7d1fe9-3bf7-4e62-9ddf-a66874561d70" class="bulleted-list"><li style="list-style-type:disc">初始化 PCB；</li></ul><ul id="0f1b638d-8410-4d50-ad2a-462928fc0439" class="bulleted-list"><li style="list-style-type:disc">如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；</li></ul></details></li></ul><ul id="c712eb18-18bc-4547-adda-267b88d3768c" class="toggle"><li><details open=""><summary>终止</summary><ul id="93b0cb4d-57f9-4990-82a1-b4947e94b4d1" class="toggle"><li><details open=""><summary>三种终止方式</summary><ul id="69d48f87-ad8c-4a95-bdaa-343e5e715884" class="toggle"><li><details open=""><summary>正常结束</summary></details></li></ul><ul id="433cc4ad-1396-4782-8bb6-18e895d70c15" class="toggle"><li><details open=""><summary>异常结束</summary></details></li></ul><ul id="ba24bb80-2bbc-4eaa-bbca-b87a95c6a3ef" class="toggle"><li><details open=""><summary>外界干预</summary></details></li></ul></details></li></ul><ul id="316286ce-7b60-451e-a79d-57f5cddb336e" class="toggle"><li><details open=""><summary>过程</summary><ul id="1d1c2f68-4d05-4830-b99c-c8c9aa9a6e13" class="bulleted-list"><li style="list-style-type:disc">查找需要终止的进程的 PCB；</li></ul><ul id="6fa4b681-bce2-4524-984e-847a47e0f70d" class="bulleted-list"><li style="list-style-type:disc">如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li></ul><ul id="6fa230e1-dd89-4b83-952d-fd35d8ab64bc" class="bulleted-list"><li style="list-style-type:disc">如果其还有子进程，则应将其所有子进程终止；</li></ul><ul id="8d494fed-1882-4f2e-827e-1d490aca1a16" class="bulleted-list"><li style="list-style-type:disc">将该进程所拥有的全部资源都归还给父进程或操作系统；</li></ul><ul id="90058dba-9bab-458f-a28d-db16eb430f11" class="bulleted-list"><li style="list-style-type:disc">将其从 PCB 所在队列中删除；</li></ul></details></li></ul></details></li></ul><ul id="479f56ff-1083-45af-8f1d-3f2c11b36413" class="toggle"><li><details open=""><summary>阻塞</summary><ul id="3929cf11-cad4-4d38-ab8c-2c0cc118ca3b" class="toggle"><li><details open=""><summary>进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</summary></details></li></ul><ul id="8d4c9318-ec10-4c7a-beac-53a2b2db87c7" class="toggle"><li><details open=""><summary>阻塞进程的过程如下：</summary><ul id="0aaa5ba5-e33a-4f9f-943a-79b33933f771" class="bulleted-list"><li style="list-style-type:disc">找到将要被阻塞进程标识号对应的 PCB；</li></ul><ul id="0c7d0a17-ef7d-4606-a7a6-49246bc2ec97" class="bulleted-list"><li style="list-style-type:disc">如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li></ul><ul id="7ea6beaa-b640-4adb-8767-450f5cdb0178" class="bulleted-list"><li style="list-style-type:disc">将该 PCB 插入的阻塞队列中去；</li></ul></details></li></ul></details></li></ul><ul id="d959db8c-ac34-4d86-912f-9b636ee133f9" class="toggle"><li><details open=""><summary>唤醒</summary><ul id="87268bde-ac7a-48f9-88ff-be8307fe707f" class="bulleted-list"><li style="list-style-type:disc">该事件的阻塞队列中找到相应进程的 PCB；</li></ul><ul id="4a0382db-74a2-404c-b026-7d73c4ded7b0" class="bulleted-list"><li style="list-style-type:disc">将其从阻塞队列中移出，并置其状态为就绪状态；</li></ul><ul id="d6d1d668-1da1-4f67-b4e6-9ae553deeead" class="bulleted-list"><li style="list-style-type:disc">把该 PCB 插入到就绪队列中，等待调度程序调度；</li></ul></details></li></ul></details></li></ul><p id="2aec750d-277d-49a6-8dcf-a3a8f1354cab" class="">将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p><p id="2c1fc594-ba22-4005-a9d4-68b97d2aa1af" class="">通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p></details></li></ul><ul id="468a2409-41b5-4362-b56d-7b40fc3e4832" class="toggle"><li><details open=""><summary><mark class="highlight-red"><a href="https://zhuanlan.zhihu.com/p/225162322"><strong>CPU调度算法</strong></a></mark><mark class="highlight-red"><strong> </strong></mark></summary><ul id="1c2cf77d-866d-46f7-80d8-8e2fa6583f88" class="toggle"><li><details open=""><summary>为何存在调度算法 ？</summary><p id="f3b03400-64bb-416c-8f99-83202cad01bf" class="">（关键是CPU<mark class="highlight-red">想提高效率</mark>）</p><ul id="68c01ff8-b074-4ab5-888e-b1d4dede01ad" class="toggle"><li><details open=""><summary>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</summary></details></li></ul><ul id="54f9aaeb-5ae3-4ec5-a7c2-2a40be32f0f6" class="toggle"><li><details open=""><summary>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</summary></details></li></ul></details></li></ul><ul id="22460e53-b6e7-4a34-9d7e-28c364dd5a1d" class="toggle"><li><details open=""><summary>调度原则</summary><ul id="011bf869-6548-4ebf-8717-96a5bc23c4f7" class="bulleted-list"><li style="list-style-type:disc"><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li></ul><ul id="a1c03c0d-8db8-4380-8b4b-a57d90179a20" class="bulleted-list"><li style="list-style-type:disc"><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li></ul><ul id="ec5f727c-62b5-4f30-8921-9f8f7f8ae0ee" class="bulleted-list"><li style="list-style-type:disc"><strong>周转时间</strong>：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；</li></ul><ul id="c136f87b-d091-4b14-91a3-d85963218817" class="bulleted-list"><li style="list-style-type:disc"><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li></ul><ul id="e6494343-8b23-4e14-97b4-334a3c6400be" class="bulleted-list"><li style="list-style-type:disc"><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ul></details></li></ul><ul id="f75541da-aec7-4994-8fe2-ccff776534d3" class="toggle"><li><details open=""><summary>分类：</summary><ul id="858b83a6-ce26-4e91-b74d-9ab27f30ca6b" class="toggle"><li><details open=""><summary><strong>非抢占式</strong></summary><p id="872c3cc1-c46c-4386-a15c-62b26ab4c4bb" class="">挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</p></details></li></ul><ul id="a1dc80f0-38dd-4c5f-b049-21c193752960" class="toggle"><li><details open=""><summary><strong>抢占式</strong></summary><p id="a9e033e1-cbe7-4b8c-83a8-b134581fdaf9" class="">挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，<strong>该进程仍然在运行时，则会把它挂起</strong>，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</p></details></li></ul><ul id="0742c7d4-f385-4161-b40f-350a058504f7" class="toggle"><li><details open=""><summary>如何判断</summary><p id="dd8b6f8b-f2fe-4ab9-b587-0ebff483d992" class="">请考虑以下四个参数：<strong>仅条件1和4适用，调度称为非抢先。所有其他调度都是抢占式的。</strong></p><ol type="1" id="11f52f8c-8426-4642-bc46-f03c6be1b5cd" class="numbered-list" start="1"><li>进程从运行状态切换到等待状态。</li></ol><ol type="1" id="03a0f99c-e8ea-4d6f-9a17-340652754e11" class="numbered-list" start="2"><li>特定过程从运行状态切换到就绪状态。</li></ol><ol type="1" id="d4412754-2dbd-46e3-b88e-b1425bac048c" class="numbered-list" start="3"><li>特定过程从等待状态切换到就绪状态。</li></ol><ol type="1" id="ddd77ecb-5b7d-4866-a39c-44a481840654" class="numbered-list" start="4"><li>进程完成其执行并终止。</li></ol></details></li></ul></details></li></ul><ul id="79df938f-565c-422f-b79c-62bfe6884c76" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>单核 CPU 系统中常见的调度算法（定义&amp;优缺点</strong></mark>）</summary><ul id="dd6f9a45-f311-4146-a869-25975f3f42e1" class="toggle"><li><details open=""><summary>先来先服务（First Come First Severd, FCFS）</summary><ul id="37a89cba-af9c-4831-bfae-123c0a75dd18" class="toggle"><li><details open=""><summary>先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</summary></details></li></ul><figure id="4a78da48-1f31-431e-b07f-ccc51482c4ad" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%203.png"><img style="width:986px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%203.png"/></a></figure><p id="54f015ff-f999-4eac-ba36-e87353b61cd4" class="">这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p id="87bcbbf3-0e28-4029-a1c8-5ad44d43c741" class="">FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。</p></details></li></ul><ul id="e0fee0d8-18fe-4de8-91e1-9429dc031b80" class="toggle"><li><details open=""><summary>最短作业优先（Shortest Job First, SJF）</summary><ul id="7cc33e1c-8a17-43a2-ba51-60026007d173" class="toggle"><li><details open=""><summary>顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。</summary></details></li></ul><figure id="385e7a20-044c-4499-84a2-28102298c585" class="image"><a href="https://pic2.zhimg.com/80/v2-aade0ab1b10cbdbc5722e7964fee9a29_720w.jpg"><img style="width:624px" src="https://pic2.zhimg.com/80/v2-aade0ab1b10cbdbc5722e7964fee9a29_720w.jpg"/></a></figure><p id="870cec4f-02cb-404b-9c12-63bc72abe8a0" class="">这显然对长作业不利，很容易造成一种极端现象。</p><p id="3d6af616-7bf3-4741-b5c6-bebf67d0754c" class="">比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p></details></li></ul><ul id="13d5bfef-dd09-4d67-a9d1-a240d33014d0" class="toggle"><li><details open=""><summary>高响应比优先 （Highest Response Ratio Next, HRRN）</summary><ul id="7417019b-1e91-415d-9587-5811c09820e1" class="toggle"><li><details open=""><summary>主要是权衡了短作业和长作业</summary></details></li></ul><ul id="2677a8a3-1b09-4d01-b9fa-97263c230208" class="toggle"><li><details open=""><summary>每次进行进程调度时，<mark class="highlight-red">先计算「响应比优先级</mark>」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：</summary><figure id="a60a430c-745f-466a-a9d5-088f09771bb4" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%204.png"><img style="width:336px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%204.png"/></a></figure></details></li></ul><ul id="96564ff7-1f62-41ab-978a-ca89fb50e2da" class="toggle"><li><details open=""><summary>从上面的公式，可以发现：</summary><ul id="87e9268c-4803-4345-8844-05a93daef9cf" class="bulleted-list"><li style="list-style-type:disc">如果两个进程的「等待时间」相同时，「<mark class="highlight-red">要求的服务时间</mark>」越短，「响应比」就越高，这样<mark class="highlight-red">短作业</mark>的进程容易被选中运行；</li></ul><ul id="ad718bdc-0a4a-4e6f-9478-d226d5f82cbc" class="bulleted-list"><li style="list-style-type:disc">如果两个进程「要求的服务时间」相同时，「<mark class="highlight-red">等待时间</mark>」越长，「响应比」就越高，这就兼顾到了<mark class="highlight-red">长作业</mark>进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li></ul></details></li></ul></details></li></ul><ul id="20cc4df7-5e30-4145-86bb-9fc216066470" class="toggle"><li><details open=""><summary>时间片轮转（Round Robin, RR）</summary><p id="3c77e49f-93d0-4534-b7f6-2adb5e660e73" class="">最古老、最简单、最公平且使用最广的算法</p><ul id="e00482b0-6f3a-4560-9751-f4b35ac1c344" class="toggle"><li><details open=""><summary>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</summary><ul id="df6ec36f-8e54-4bef-82d5-74388eaaec7e" class="bulleted-list"><li style="list-style-type:disc">如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li></ul><ul id="c1708062-b422-4a41-bb03-4e2a83648330" class="bulleted-list"><li style="list-style-type:disc">如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul></details></li></ul><figure id="2faa84b0-e7a3-4096-b3eb-77e8d577f979" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%205.png"><img style="width:528px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%205.png"/></a></figure><ul id="a40b7671-8838-4526-a781-7d90fe7d8782" class="toggle"><li><details open=""><summary>一个很关键的点：</summary><ul id="8a1a2708-bff4-4080-8c40-408bffe57ee7" class="bulleted-list"><li style="list-style-type:disc">如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li></ul><ul id="713ebec4-3687-459c-8bd1-aeefc1711667" class="bulleted-list"><li style="list-style-type:disc">如果设得太长又可能引起对短作业进程的响应时间变长。将通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。</li></ul></details></li></ul></details></li></ul><ul id="e33ba13b-4fcd-48d2-ba88-10f234930fab" class="toggle"><li><details open=""><summary>最高优先级（Highest Priority First，HPF）</summary><p id="f587b351-af06-4249-a36a-e0c667ecf330" class="">多用户计算机系统： 希望调度是有优先级的，即希望调度程序<strong>能从就绪队列中选择最高优先级的进程进行运行</strong>，这称为最高优先级（Highest Priority First，HPF）调度算法。</p><ul id="dc298137-75c4-4166-ac07-00ca2cb921e7" class="toggle"><li><details open=""><summary>进程的优先级可以分为，静态优先级或动态优先级：</summary><ul id="8b88b878-4cc3-412d-adaf-85b85e88ca95" class="bulleted-list"><li style="list-style-type:disc">静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li></ul><ul id="734c65bd-e01b-4650-bfa1-8ea535b4b215" class="bulleted-list"><li style="list-style-type:disc">动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><ul id="53b3ca56-1216-4998-9b40-fd3885ebc49e" class="toggle"><li><details open=""><summary>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</summary><ul id="b5103a78-7f9f-4898-a042-8c6c1517c0c6" class="bulleted-list"><li style="list-style-type:disc">非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li></ul><ul id="e7ae31eb-2a18-4d1b-aba9-918b47ecd569" class="bulleted-list"><li style="list-style-type:disc">抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p id="57f71a5a-2070-4ccf-9102-eeb4bbcd441a" class="">但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p></details></li></ul></details></li></ul><p id="e307adf8-4c9a-4255-b0e7-2786f9f1da9b" class="">
</p></details></li></ul><ul id="99ab7546-5846-4d64-bec2-dff8b037e63d" class="toggle"><li><details open=""><summary><mark class="highlight-pink_background">多级反馈队列</mark>（Multilevel Feedback Queue）</summary><p id="e201e635-3ca0-4349-83b8-2548d6c6704a" class="">「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><ul id="e5c0760e-1162-468d-afe3-7e54baaaa339" class="toggle"><li><details open=""><summary>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</summary></details></li></ul><ul id="5fbe2ef8-aa98-4554-83d2-931ccb45031d" class="toggle"><li><details open=""><summary>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</summary><figure id="4018d7cc-8230-4d4d-9bdb-0b773e1fca71" class="image"><a href="https://pic4.zhimg.com/80/v2-5ea155d8d6eb0f1d48afd347b5c7cc2f_720w.jpg"><img src="https://pic4.zhimg.com/80/v2-5ea155d8d6eb0f1d48afd347b5c7cc2f_720w.jpg"/></a></figure></details></li></ul><ul id="bf414ce3-0afa-4ad2-b00a-84ff9d76d063" class="toggle"><li><details open=""><summary>来看看，它是如何工作的：</summary><ul id="078ec9da-e59c-4eb6-8ac0-c24576087ca3" class="bulleted-list"><li style="list-style-type:disc">设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li></ul><ul id="3abf3984-d45f-4262-9fcf-8039b132a4e7" class="bulleted-list"><li style="list-style-type:disc">新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li></ul><ul id="47f63c33-602c-432c-8af4-3a1db7389eed" class="bulleted-list"><li style="list-style-type:disc">当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p id="7c8b9ffe-c35e-4c72-a53b-8f1a328fe7ea" class="">可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p></details></li></ul></details></li></ul></details></li></ul><ul id="b3ce65f2-007d-4cdc-b0b4-0d32a69a0363" class="toggle"><li><details open=""><summary>拓展：<a href="https://blog.csdn.net/u013616945/article/details/69569267">交互系统调度算法</a></summary></details></li></ul></details></li></ul><p id="4500cd0f-a930-4db5-96b2-dc2fbe284c49" class="">
</p><ul id="e8feb79b-7edb-431a-8342-85b115dc1aee" class="toggle"><li><details open=""><summary>异常 vs 中断</summary><p id="cf7f647b-ed07-4482-bd07-d28b18f5e1f3" class="">中断主要分为两类：</p><ul id="7f7322b0-4ea7-496a-bfe7-0e8c2a7ae458" class="toggle"><li><details open=""><summary><mark class="highlight-red">同步</mark>中断和异常（也称<mark class="highlight-red">内中断</mark>、<mark class="highlight-red">例外</mark>或<mark class="highlight-red">陷入</mark>(Trap) ）</summary><p id="d032710c-a41c-4bdb-b137-14b11fea5733" class="">指源自<mark class="highlight-red">这些由CPU自身产生，针对当前执行的程序</mark>。如程序的非法操作码、 地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。</p><p id="03506e32-1e84-40ac-89c7-941b6105d5c4" class="">异常情况不见得是由进程直接导致的，<mark class="highlight-red">但必须借助于内核才能修复</mark>。一个可能的例子是缺页异常，在进程试图访问虚拟地址空间的一页，而该页不在物理内存中时，才会发生此类异常。</p></details></li></ul><ul id="39f9019e-71bf-4bb3-867a-dd8a578722e9" class="toggle"><li><details open=""><summary><mark class="highlight-red">异步</mark>中断：</summary><p id="e684ebe2-5e65-4566-958e-f6ce468ddff4" class="">中断(Interruption)，也称外中断，指<mark class="highlight-red">来自CPU执行指令以外的事件的发生</mark>。由外部设备产生，可能发生在任意时间。</p><p id="8a55e399-311a-4516-bece-826f8b31b182" class="">异步中断并不与特定进程关联。</p><p id="1f6e75b6-da66-4590-8e71-c62c10f6d8cf" class="">网卡通过发出一个相关的中断来报告新分组的到达。因为数据可能在任意时刻到达系统，所以当前执行的很可能是与数据无关的某个进程或其他东西。为避免损害该进程，内核必须确保中断能够尽快处理完毕（通过缓冲数据），使得CPU时间能够返还给当前进程。这也是内核需要延期操作机制的原因，该机制也在本章讨论。</p></details></li></ul><ul id="195c5d2f-e023-4981-9cfd-19fc1ffb6287" class="toggle"><li><details open=""><summary>中断怎么处理 &amp; 复原</summary><p id="57dae7ae-cc6b-4c5d-b04e-208c3a9f498b" class="">中断处理划分为3部分。</p><p id="f984cb52-ebe4-49f8-8152-55f2fe5137b3" class="">首先，必须建立一个适当的环境，使得处理程序函数能够在其中执行，</p><ul id="4dc4c05f-27e4-44d2-8402-8724592547f2" class="toggle"><li><details open=""><summary>接下来调用处理程序自身，</summary><p id="52387b2a-bc50-494d-84c3-5a51b59590e6" class="">调用中断处理程序前后的两部分，分别称为进入路径(entry path)和退出路径(exit path)。进入和退出任务还负责确保处理器从用户态切换到核心态。</p><p id="533c18c9-ddb4-4e4d-975a-edaa46c81e69" class=""><mark class="highlight-red">进入路径</mark>的一个关键任务是，从<mark class="highlight-red">用户态栈切换到核心态</mark>栈。但是，只有这一点还不够。因为内核还要使用CPU资源执行其代码，<mark class="highlight-red">进入路径必须保存用户应用程序当前的寄存器状态，以便在中断活动结束后恢复。</mark>这与调度期间用于上下文切换的机制是相同的。在进入核心态时，只保存整个寄存器集合的一部分。内核并不使用全部寄存器。举例来说，内核代码中不使用浮点操作(只有整数计算)，因而并不保存浮点寄存器。1浮点寄存器的值在执行内核代码时不会改变。平台相关的数据结构pt_regs列出了核心态可能修改的所有寄存器， 5它的定义考虑到了不同的CPU之间的差别(14.1.7节将仔细考察该结构)。在汇编语言编写的底层例程负责填充该结构。</p><p id="db9d92a3-754f-4b8b-8e9f-96395d44e671" class="">在<mark class="highlight-red">退出路径</mark>中，内核会检查下列事项。
 调度器是否应该选择一个新进程代替旧的进程。
 是否有信号必须投递到原进程。
从中断返回之后，只有确认了这两个问题，内核才能完成其常规任务，即还原寄存器集合、切换到用户态栈、切换到适用于用户应用程序的适当的处理器状态，或切换到一个不同的保护环。</p></details></li></ul><p id="eb7ce173-242a-495f-ac38-7e31e29159cb" class="">最后将系统复原(在当前程序看来)到中断之前的状态。</p><figure id="c8635dcb-5a73-4f72-b9a5-d0118994377a" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%206.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%206.png"/></a></figure></details></li></ul><ul id="7e8b7dec-57c9-4b41-9b62-5ffabc7e0074" class="toggle"><li><details open=""><summary>共同特性：如果CPU当前不处于核心态，则发起从用户态到核心态的切换。</summary></details></li></ul></details></li></ul><ul id="d41f3280-7c49-4ab4-aeb3-c150155d6790" class="toggle"><li><details open=""><summary><mark class="highlight-red">惊群效应</mark></summary><ul id="5658d6f7-2b85-4e94-9ff1-e81fcaa830cf" class="toggle"><li><details open=""><summary><a href="https://www.zhihu.com/question/22756773">定义</a>：</summary><ul id="3165db81-26b7-4a84-8a0c-d253acd75254" class="toggle"><li><details open=""><summary>指<mark class="highlight-red">多进程</mark>（多线程）在<mark class="highlight-red">同时阻塞等待同一个事件</mark>的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却<mark class="highlight-red">只能有一个进程</mark>（线程）获得这个时间的“<mark class="highlight-red">控制权</mark>”，对该事件进行处理，而其他进程（线程）获取“控制权”<mark class="highlight-red">失败</mark>，只能重新<mark class="highlight-red">进入休眠</mark>状态，这种现象和性能浪费就叫做惊群效应。</summary></details></li></ul><ul id="ca225db3-6453-47e2-9cc1-3cc1be6c6a08" class="toggle"><li><details open=""><summary>都醒了，但只能有一个醒，其他只好睡下</summary></details></li></ul></details></li></ul><ul id="258516ae-2578-4f13-8b94-1939edec000e" class="toggle"><li><details open=""><summary>性能损耗详解</summary><ul id="c5dc9d33-300b-4127-9b28-d4dd77b60772" class="toggle"><li><details open=""><summary>系统对用户进程/线程<mark class="highlight-red">频繁</mark>地做无效的调度，<mark class="highlight-red">上下文切换</mark>系统性能大打折扣。</summary><p id="afd41273-1b3f-460e-8528-60789c89abdb" class="">*1、上下文切换（context  switch）过高会导致cpu像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括cpu寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核cache之间的共享数据。</p></details></li></ul><ul id="fabc961b-9c88-45e0-83fb-f39f6dccb491" class="toggle"><li><details open=""><summary>为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。</summary><p id="8ce6732f-e81e-4bce-a43d-834fd8c94dc9" class="">*2、通过锁机制解决惊群效应是一种方法，在任意时刻只让一个进程（线程）处理等待的事件。但是<mark class="highlight-red">锁机制也会造成cpu等资源的消耗</mark>和性能损耗。目前一些常见的服务器软件有的是通过锁机制解决的，比如nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如lighttpd。</p></details></li></ul></details></li></ul><ul id="e554177c-522b-42cc-b4c6-1d60a0c06df1" class="toggle"><li><details open=""><summary>性能损耗详解 - 源码角度分析</summary><ul id="975d4355-6328-4b90-9a3e-fcdcb405bac4" class="toggle"><li><details open=""><summary><strong>accept() 惊群：</strong></summary></details></li></ul><ul id="0783134a-79d0-4391-bcf1-74902f310459" class="toggle"><li><details open=""><summary><strong>epoll() 惊群：</strong></summary></details></li></ul><ul id="6fe639cb-aeb7-4b45-a954-c454bce3ba39" class="toggle"><li><details open=""><summary><strong>线程惊群：</strong></summary></details></li></ul></details></li></ul><ul id="f108d852-4467-4d6e-b0b5-e1cfd87ee6ca" class="toggle"><li><details open=""><summary><a href="https://blog.csdn.net/lyztyycode/article/details/78648798">如何解决</a></summary><p id="5a23c86e-7f5d-47b0-9cdb-f82b6be4473a" class="">解决办法可能有： 不希望把所有进程都唤醒，就采用定点唤醒某一个进程的做法。 尽量避免进程上下文切换。</p></details></li></ul></details></li></ul><p id="75c402bc-3eb2-42e3-8ef1-0daf259b4731" class="">
</p><p id="8b636a72-03d1-455d-9443-30c9418e64ed" class="block-color-orange_background">通信</p><ul id="061f7847-4bec-45aa-886a-cd0fc6943624" class="toggle"><li><details open=""><summary><mark class="highlight-red"><a href="https://blog.csdn.net/weixin_41413441/article/details/80548683">互斥 &amp; 同步 &amp; 通信</a></mark></summary><ul id="f75e49fc-805b-4d20-84be-76f0927330a2" class="toggle"><li><details open=""><summary>并发与时间片</summary><p id="72266a2c-47fc-4c4b-8bd9-bfe7cb6258bd" class="">在单核 CPU 系统⾥，为了实现多个程序同时运⾏的假象，操作系统通常以时间⽚调度的⽅式，<mark class="highlight-red">让每个进程 执⾏每次执⾏⼀个时间⽚</mark>，<mark class="highlight-red">时间⽚⽤完了，就切换下⼀个进程运⾏</mark>，由于这个时间⽚的时间很短，于是就造成了<strong>「并发」</strong>的现象。</p><p id="267c3efa-47b8-4c62-b320-0d17938e7000" class="">另外，操作系统也为每个进程创建巨⼤、私有的虚拟内存的假象，这种地址空间的抽象让每个程序好像拥 有⾃⼰的内存，⽽实际上操作系统在背后秘密地<strong>让多个虚拟地址空间「复⽤」物理内存或者磁盘</strong>。</p><p id="35babe15-eb98-4901-936d-83ab0b9f2fa8" class="">不加锁冲突容易发生墨菲定律：<a href="https://www.cnblogs.com/xiaolincoding/p/13346658.html">多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱。为什么会发生这种情况</a>?</p><ul id="5133b529-7b72-4233-84ac-a03796f7c2b6" class="toggle"><li><details open=""><summary>在这个例子中，我们只是想给 <code>i</code> 加上数字 1，那么它对应的汇编指令执行过程是这样的：</summary><figure id="d2763807-0f1d-472b-9298-7b5f0aeaa5d5" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNjUzMmRmMC1mYjU5LTQ3ZmMtOTFlOC1hZTZiNWRiZmM1ZTIucG5n?x-oss-process=image/format,png"><img style="width:288px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNjUzMmRmMC1mYjU5LTQ3ZmMtOTFlOC1hZTZiNWRiZmM1ZTIucG5n?x-oss-process=image/format,png"/></a></figure><p id="4b39b4b7-498d-4053-94af-8da4c2bdd80d" class="">可以发现，只是单纯给 <code>i</code> 加上数字 1，在 CPU 运行的时候，实际上要执行 <code>3</code> 条指令。</p><p id="d7d552cf-de66-42e0-b7e1-83e7a87d25e2" class="">
</p><figure id="4387f75b-92ee-4037-b2e4-a3f2657c6e5a" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%207.png"><img style="width:902px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%207.png"/></a></figure></details></li></ul></details></li></ul><ul id="ecce119f-a087-42c8-b13b-91d4938e23ef" class="toggle"><li><details open=""><summary>互斥 &amp; 同步</summary><p id="3e1dc6bc-1573-4f34-852a-6783501d90cc" class="">在多道程序设计系统中，同一时刻可能有许多进程，这些<mark class="highlight-red">进程之间存在两种基本关系：竞争关系和协作关系</mark>。</p><ul id="28db0c25-ef68-4f9d-9c2e-f7ac7af8560a" class="toggle"><li><details open=""><summary><strong>竞争关系 &amp; 互斥</strong></summary><ul id="346872cb-974c-4b76-860d-2f45368b3413" class="toggle"><li><details open=""><summary>例子-小故事：</summary><p id="6f431e5c-6259-425d-a80b-2a8e606e83f9" class="">到了厕所（共享资源），由于内急⼩明直接冲⼊厕所，第⼀个⻔没锁⻔，便夺⻔⽽⼊。
⿊暗中，⼩红正在使用，吓一跳， ⼀脚踢了过去。
扯了那么多，实际上是为了说明，<mark class="highlight-orange_background">对于共享资源，如果没有上锁，在多线程的环境⾥，那么就可能会发⽣翻⻋现场。</mark></p></details></li></ul><ul id="dac339fb-6384-4554-b3a3-a371dc65813c" class="toggle"><li><details open=""><summary>系统中的多个进程之间彼此无关，它们并不知道其他进程的存在，并且也不受其他进程执行的影响。例如，批处理系统中建立的多个用户进程， 分时系统中建立的多个终端进程。由于这些进程共用了一套计算机系统资源，因而必然要出现多个进程<mark class="highlight-red">竞争</mark>资源的问题。当多个进程竞争共享硬设备、存储器、处理器 和文件等资源时，操作系统必须协调好进程对资源的争用。</summary><ul id="45dc4a74-19cf-459b-af8d-b0466f91b9b1" class="toggle"><li><details open=""><summary> <mark class="highlight-red">并发，时钟中断等情况称为</mark><mark class="highlight-red"><strong>竞争条件（race condition）</strong></mark><mark class="highlight-red">，</mark>当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在<strong>不确定性</strong>（<strong>indeterminate</strong>）</summary></details></li></ul><ul id="09a1005c-9f85-4ba5-a995-d999a47542d1" class="toggle"><li><details open=""><summary><strong>保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</strong>(代码执行过程中，最多只能出现一个线程)</summary></details></li></ul><ul id="22ef28e4-9e9a-45c3-8733-83a393891dda" class="bulleted-list"><li style="list-style-type:disc">互斥的方式，可保证任意时刻只有一个线程访问共享资源；互斥也并<mark class="highlight-red">不是只针对多线程</mark>。在<mark class="highlight-red">多进程竞争</mark>共享资源的时候，<mark class="highlight-red">也同样</mark>是可以使用互斥的方式来避免资源竞争造成的资源混乱。</li></ul><p id="2487eb1b-15cb-486d-a46f-4638118fc1e7" class="">
</p></details></li></ul><ul id="21c4daec-f01b-44e6-b85b-8f9255004393" class="toggle"><li><details open=""><summary>资源竞争出现了两个控制问题：</summary><p id="9d9fdead-db6d-44ff-a9a7-a32b3f2fdbfe" class="">一个是<mark class="highlight-red">死锁 </mark>（deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</p><p id="69bb64cc-6332-40ee-9064-f177c222ed0c" class="">一个是<mark class="highlight-red">饥饿</mark>（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。</p></details></li></ul><p id="5ff0d010-49f4-40bc-a213-e5a95238625f" class="">进程的互斥（mutual exclusion ）是解决进程间竞争关系( <strong>间接制约关系</strong>) 的手段。进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p><figure id="f4533b38-387b-470b-901b-aa5bf372f4a4" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%208.png"><img style="width:576px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%208.png"/></a></figure></details></li></ul><ul id="f4e1f730-b879-4888-a813-e63d1f1a5b0d" class="toggle"><li><details open=""><summary><strong>协作关系  &amp; 同步</strong></summary><p id="f6e8d193-1ea8-4b14-a902-9295dece84bf" class="">（eg：某个进程等待另一个进程的信号）</p><p id="9fb08fbc-f1ae-4883-ac52-4340c031ef1d" class=""><mark class="highlight-red">某些进程为完成同一任务需要分工协作</mark>，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协 调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。<mark class="highlight-red">这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。</mark></p><p id="e7f47592-5d5b-4289-afb5-b769c47f6061" class="">同步概念： 协调进程执行顺序</p><ul id="1faedf77-9cc6-460d-8ee0-ee2a92c60a03" class="toggle"><li><details open=""><summary>例子</summary><p id="3a2a30ba-88c3-45b3-986b-e54c033cd6a6" class="">举个⽣活的同步例⼦，你肚⼦饿了想要吃饭，你叫妈妈早点做菜，妈妈听到后就开始做菜，但是在妈妈没 有做完饭之前，你必须阻塞等待，等妈妈做完饭后，⾃然会通知你，接着你吃饭的事情就可以进⾏了。</p><figure id="6b0322d4-1cb8-44db-a661-2e1b0d2bd5e6" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%209.png"><img style="width:384px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%209.png"/></a></figure></details></li></ul><p id="dcdde5e0-3627-450a-996f-3ac1dcfe7b0c" class="">进程间的协作可以是双方不知道对方名字的间接协作，例如，通过共享访问一个缓冲区进行松散式协作；也可以是双方知道对方名字，直接通过通信机制进行紧密协作。允许进程协同工作有利于共享信息、有利于加快计算速度、有利于实现模块化程序设计。</p><p id="d4ce3d6e-ea51-46f0-9334-d2540768be5c" class="">进程的同步（Synchronization）是解决进程间协作关系( <strong>直接制约关系</strong>) 的手段。</p><p id="21524cab-3af6-4e1d-aae8-2a67df9f4557" class="">进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。</p></details></li></ul><p id="51217966-91c3-458b-b951-c65d18efe2de" class="">不难看出，<mark class="highlight-red">进程互斥关系是一种特殊的进程同步关系</mark>，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。</p><p id="46816c97-0039-4401-9079-dcbd59ffd4bf" class="">进程的互斥、同步、通信都是基于这两种基本关系而存在的。<div class="indented"><p id="46d1f903-23fc-4592-813e-1702d6efca4a" class="">为了解决进程间<mark class="highlight-red">竞争关系</mark>（间接制约关系）而引入进程<mark class="highlight-red">互斥</mark>；</p><p id="1603d4ac-4476-444e-88c0-f6451aa851cc" class="">为了解决进程间<mark class="highlight-red"><strong>松散的协作</strong></mark><mark class="highlight-red">关系(</mark> <strong>直接制约关系</strong>)而引入进程<mark class="highlight-red">同步</mark>；</p><p id="ce34f975-31d4-4ab6-95e7-6e3959ac7685" class="">为了解决进程间<mark class="highlight-red"><strong>紧密的协作</strong></mark><mark class="highlight-red">关系</mark>而引入进程<mark class="highlight-red">通信</mark>。</p><p id="2021b6e0-0d1d-4551-9727-eefa92b54721" class="">
</p></div></p></details></li></ul><ul id="6410f8bc-3be8-45e1-bd64-b37ad019381e" class="toggle"><li><details open=""><summary>通信</summary><p id="03801e0d-0f2d-4915-b776-1ce89d3f62d1" class="">并发进程之间的交互必须满足两个基本要求：同步和通信。</p><p id="f81d77d8-ff88-4637-a3a5-a7b6983b5185" class="">进程竞争资源时要实施互斥，互斥是一种特殊的同步，进程同步是一种进程通信。</p><p id="ba32ceb5-34c7-4ce4-a417-98aae8582e1d" class="">广泛意义上：仅仅<mark class="highlight-red">交换某个状态信息</mark>。例如 <mark class="highlight-red">信号量与PV操作只能传递信号，没有传递数据的能力</mark>。通过修改信号量，进程之间可建立起联系，相互协调运行和协同工作。</p><p id="d5dc286d-a7ce-4a71-a5e7-a5c422bb1f87" class="">严格意义上：很多情况下进程之间需要<mark class="highlight-red">交换大批数据</mark>，例如，传送一批信息或整个文件，这可以通过一种新的通信机制来完成，<strong>进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。</strong></p></details></li></ul><figure id="5089bf3f-0d5b-4835-864a-aaf4c9086b43" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2010.png"><img style="width:361px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2010.png"/></a></figure><table id="b2274a00-86c5-44d4-bf9d-687c5785d4f2" class="simple-table"><tbody><tr id="22966366-0d76-4826-8586-5dc531a382b7"><td id="b^TL"></td><td id="Z`NU">多线程</td><td id="Ntw}">多进程</td><td id="ATb?"></td></tr><tr id="3fbcd27b-0ae1-488b-8c41-5d9b5851705f"><td id="b^TL">互斥</td><td id="Z`NU"><strong>临界区(CcriticalSection)
</strong>互斥量(mutex)</td><td id="Ntw}"><strong>临界区(CcriticalSection)
</strong>互斥量(mutex)</td><td id="ATb?">临界区用户模式，手动释放
互斥量内核模式</td></tr><tr id="4b28eb7c-787f-457a-9f5b-139dcbc18fa5"><td id="b^TL">同步</td><td id="Z`NU">信号量(P, V)
事件(event)</td><td id="Ntw}">信号量(P, V)
事件(event)
管程</td><td id="ATb?">信号量，事件 内核模式</td></tr><tr id="0e05d5e1-e8a4-4973-932f-81255c38f101"><td id="b^TL">通信
(狭义)</td><td id="Z`NU">内存共享(全局变量？，同一进程内的线程)</td><td id="Ntw}">管道
消息队列
共享内存
信号
网络（套接字）</td><td id="ATb?"></td></tr><tr id="461fa717-4586-42e2-85fb-74cb8ee3fd4b"><td id="b^TL">注：</td><td id="Z`NU">下方包含上方</td><td id="Ntw}"></td><td id="ATb?"></td></tr></tbody></table></details></li></ul><ul id="e56c3643-0696-4ddd-9ffc-513177e18dcc" class="toggle"><li><details open=""><summary>互斥</summary><ul id="466ce8c9-5208-4cad-9b38-433fade81579" class="toggle"><li><details open=""><summary>pre：锁(lock)</summary><ul id="b2713a19-608b-4d88-af5f-2c65f321e304" class="toggle"><li><details open=""><summary>加锁的目的</summary><p id="5cfcf3b8-fe1d-43f4-828d-08eee21089b0" class="">使⽤加锁和解锁可以解决并发线程/进程的<mark class="highlight-red">互斥</mark>问题。</p><p id="b71bd00e-204b-474d-8d75-02792eb7f91a" class="">保证共享资源在任意时间里，只有一个线程访问，这样就可以<mark class="highlight-red">避免多线程导致共享数据错乱</mark>的问题。<strong>任何想进入临界区的线程-先加锁。</strong>若操作顺利，则线程可进入临界区；<strong>在完成对临界资源的访问后再执行解锁操作</strong>，以释放该临界资源</p><p id="70e510bd-0aaf-4b06-904c-fae991413d8d" class="">如果选择了错误的锁，在一些高并发的场景可能会降低系统的性能。为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多⼤，还需要分析业务场景中访问的 共享资源的⽅式，再来还要考虑并发访问共享资源时的冲突概率。</p></details></li></ul><ul id="28ed428a-0b8c-4118-a2d3-27ec58145bc5" class="toggle"><li><details open=""><summary>种类&amp; 定义</summary><ul id="55323e1c-db6d-47c1-93cd-1a96d25fb004" class="toggle"><li><details open=""><summary>互斥锁与自旋锁 - 最底层</summary><ul id="c91d5370-1e74-4410-8029-798335f9b578" class="toggle"><li><details open=""><summary>互斥锁</summary><p id="a918989e-ceda-4865-94a5-ee86acda6222" class="">提供了以排他方式防止数据结构被并发修改的方法。</p><p id="71193440-a3a0-44df-8cb9-4aa725ddd774" class=""><mark class="highlight-red"><strong>互斥锁</strong></mark><mark class="highlight-red">确保同一时间只能有一个线程访问共享资源</mark>。当锁被占用时试图对其加锁的线程都<mark class="highlight-red">进入阻塞状态</mark>(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</p><ul id="89e4a804-5fd5-4b47-bd72-a24337cf9565" class="toggle"><li><details open=""><summary>linux 下实现原理 <mark class="highlight-red">条件变量</mark><a href="https://www.jianshu.com/p/a7ddb2998b3b"><mark class="highlight-red"> 源码</mark></a><mark class="highlight-red">：</mark></summary><p id="a9e2446a-8edc-42a0-b2bb-76e7cdf85179" class="">互斥锁的实现，实际上就是一把锁维护了一个等待队列和一个引用计数器，</p><p id="f08b331b-9b54-473b-855a-eb1b11b67c41" class="">当获取锁之前，先对引用计数器减1操作，
如果为非负，则可以获取锁进入临界区。
否则需要将该任务挂在该等待对列上。</p></details></li></ul><ul id="50906992-e3f8-4fe0-911a-536d949f864a" class="toggle"><li><details open=""><summary>面试手撕代码 <mark class="highlight-red"><strong>mutex互斥锁怎么实现?</strong></mark></summary><p id="e32d9f33-e641-40ce-9b10-9add96f9a8cf" class="">可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p><p id="c95142ad-1ba3-4911-9fe9-d3c9c56a1f73" class=""><a href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p><p id="b875f7c5-50e2-414c-b91a-2723f94dc5c9" class="">实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。
实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p><pre id="9073e140-22fa-4aad-a083-8166319b4722" class="code"><code>static int flag=0;

void lock(){
  while(TestAndSet(&amp;flag,1)==1);
  //flag=1;
}
void unlock(){
  flag=0;
}

//因为while有可能被重入，所以可以用TestandSet()方法。
int TestAndSet(int *ptr, int new) {
    int old = *ptr;
    *ptr = new;
    return old;
}</code></pre></details></li></ul><ul id="1107f43b-a37e-4a65-887d-2ebc259c622e" class="toggle"><li><details open=""><summary>无等待锁顾明思议就是获取不到锁的时候，不用自旋。</summary><p id="3cde32bd-7284-4631-9703-1a15c0cd4822" class="">既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。</p><figure id="d3b1fbb2-f380-4882-bc8b-89a38a3cdd83" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2011.png"><img style="width:2612px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2011.png"/></a></figure></details></li></ul></details></li></ul><ul id="0e039ced-8aa9-4a73-9049-5b5752f49b75" class="toggle"><li><details open=""><summary><strong>自旋锁</strong></summary><p id="f09faf5a-33d0-44a6-84b9-dd0434f6f089" class=""><mark class="highlight-red">上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁(资源？)</mark>，没有线程的切换因而没有切换开销，不过对<mark class="highlight-red">CPU的霸占</mark>会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。</p><ul id="4ccf95cc-8c99-4b60-9cb7-3820d4a1e4c0" class="toggle"><li><details open=""><summary>自旋锁如何实现？</summary><ul id="4a68994c-81ca-4d83-b8c3-bfa5161518ef" class="toggle"><li><details open=""><summary>背景知识：CPU 体系结构提供的特殊原子操作指令 ——测试和置位（Test-and-Set）指令</summary><ul id="c706208b-e20f-41b3-8b0c-652f796cbda6" class="toggle"><li><details open=""><summary>原子执行</summary><pre id="c5b8a351-f881-4c0c-a0aa-4b74ea37c3b1" class="code"><code>// google 命名风格： 函数驼峰， 变量下划线
int TestAndSet(int *old_ptr, int new)
{
		int old = *old_ptr;
		*old_ptr = new;
		return old;
}</code></pre><p id="de099832-7560-4b04-adca-3e19b232f359" class="">这些代码是原子执行。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。测试并设置指令做了下述事情:</p><ul id="9b22ac38-4118-4a7e-b676-cd195d57d895" class="bulleted-list"><li style="list-style-type:disc">把 <code>old_ptr</code> 更新为 <code>new</code> 的新值</li></ul><ul id="3487fef5-ed97-42ee-862c-bb8381bc0ce7" class="bulleted-list"><li style="list-style-type:disc">返回 <code>old_ptr</code> 的旧值；</li></ul><p id="52a9f4b9-15c9-453c-988c-f19a4519c41f" class="">当然，<strong>关键是这些代码是原子执行</strong>。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。</p></details></li></ul><ul id="8439921c-ff51-4ba6-b368-b5e99260d545" class="toggle"><li><details open=""><summary>什么是原子操作</summary><ul id="a3120cb5-a5cd-4882-b299-931b12db092a" class="toggle"><li><details open=""><summary>就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态</summary></details></li></ul><p id="f761c5b9-9f34-43e9-a77c-a26bb44a4f6c" class="">
</p></details></li></ul></details></li></ul><ul id="10ce1e17-6d99-42c7-b45c-ec3b513bb27a" class="toggle"><li><details open=""><summary>实现「忙等待锁」：</summary><figure id="f29fafc2-2b78-4f95-8642-0d4ce2332c9e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2012.png"><img style="width:2612px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2012.png"/></a></figure><p id="311f7679-ec42-4997-b176-3edbc0a259f8" class="">我们来确保理解为什么这个锁能工作：</p><ul id="239b81c0-5f12-4a59-b0e0-08f1ff8869a5" class="bulleted-list"><li style="list-style-type:disc">第一个场景是，首先假设一个线程在运行，调用 <code>lock()</code>，没有其他线程持有锁，所以 <code>flag</code> 是 0。当调用 <code>TestAndSet(flag, 1)</code> 方法，返回 0，线程会跳出 while 循环，获取锁。同时也会原子的设置 flag 为1，标志锁已经被持有。当线程离开临界区，调用 <code>unlock()</code> 将 <code>flag</code> 清理为 0。</li></ul><ul id="3f7ffdde-c871-48c8-977c-ec62334a3944" class="bulleted-list"><li style="list-style-type:disc">第二种场景是，当某一个线程已经持有锁（即 <code>flag</code> 为1）。本线程调用 <code>lock()</code>，然后调用 <code>TestAndSet(flag, 1)</code>，这一次返回 1。只要另一个线程一直持有锁，<code>TestAndSet()</code> 会重复返回 1，本线程会一直<strong>忙等</strong>。当 <code>flag</code> 终于被改为 0，本线程会调用 <code>TestAndSet()</code>，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。</li></ul><p id="d8a75bdf-4434-485c-9224-dc959a986a01" class="">很明显，当获取不到锁时，线程就会一直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为<strong>自旋锁（</strong><em><strong>spin lock</strong></em><strong>）</strong>。</p><p id="4baddee0-1378-4db9-906c-077abebbd44e" class="">这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，<strong>因为一个自旋的线程永远不会放弃 CPU。</strong></p></details></li></ul><p id="c2f7a493-0d1f-4518-8cec-f4c6d44fefef" class="">自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（Compare And Swap）实现的。  CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><ul id="c46bb200-48c6-4b4f-b894-c9fc92b960f3" class="toggle"><li><details open=""><summary>一般加锁的过程，包含两个步骤：</summary><ul id="f553157e-3550-46a5-93d0-ee231f0bec21" class="bulleted-list"><li style="list-style-type:disc">第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li></ul><ul id="aa58d274-f2db-4fec-a3fa-dc4369a2a585" class="bulleted-list"><li style="list-style-type:disc">第二步，将锁设置为当前线程持有；</li></ul></details></li></ul><div><ul id="b0b1c944-5cc3-45a4-b5d9-d6e52338c896" class="toggle"><li><details open=""><summary>CAS（Compare And Swap）</summary><ul id="c0fa0353-6b4b-4a12-90f2-d1a6de90f962" class="toggle"><li><details open=""><summary>CAS操作包括了3个操作数：</summary><ul id="cc3e5e38-7319-468b-ab74-996233b6293b" class="bulleted-list"><li style="list-style-type:disc">需要读写的内存位置(V)</li></ul><ul id="6b61054d-efc4-4ecb-aa5e-b3f57a90ea7a" class="bulleted-list"><li style="list-style-type:disc">进行比较的预期值(A)</li></ul><ul id="65266c25-c544-4179-9b44-fe946a2a5a59" class="bulleted-list"><li style="list-style-type:disc">拟写入的新值(B)</li></ul></details></li></ul><ul id="9c70055b-5851-45e4-bf26-35774f4aa0df" class="toggle"><li><details open=""><summary><mark class="highlight-red">CAS操作逻辑如下</mark>：</summary><p id="38b41903-9443-453a-bf77-e950a39cda1b" class=""><mark class="highlight-red">如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作</mark>。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p></details></li></ul><p id="9a7f26f7-c949-4261-9561-13b51f0f2341" class="">这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？答案是：CAS是由CPU支持的原子操作，其<mark class="highlight-red">原子性是在硬件层面进行保证的</mark>。</p><ul id="7fdcfe63-c6e7-4b63-84ac-4055911d9265" class="toggle"><li><details open=""><summary>缺点</summary><ul id="73b329f5-ae14-4d0b-9638-97bc81455dac" class="toggle"><li><details open=""><summary><strong>1、</strong><mark class="highlight-red"><strong>ABA问题</strong></mark></summary><ul id="aae2700c-0c3d-461e-a1e1-0816028c0664" class="toggle"><li><details open=""><summary><a href="https://www.zhihu.com/question/23281499/answer/1029690466">定义：</a></summary><p id="8f532197-8cb6-42fd-b49a-9ac9a564956d" class="">ABA的场景出现时，预期值和旧值相同会让线程以为这个值没有被改变过，然而“值相同=没有被改变过”无法成立，即使第二个线程确确实实改过这个值，只不过又改回来了。“值曾经发生过改动”这个事件就无法被观测到。对于需要跟踪值的改变过程（比如记录值改变的次数）的场景来说ABA问题就是致命的。</p></details></li></ul><ul id="1ce6d968-c55b-4091-adb6-100941eec7a9" class="toggle"><li><details open=""><summary>假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</summary><p id="d88cad06-3b7b-4a4f-be4c-0fcee6e3c15c" class="">(1)线程1读取内存中数据为A；</p><p id="e92933a0-b3bc-423d-a878-860a9d2f1bc9" class="">(2)线程2将该数据修改为B；</p><p id="bb92222c-57d4-4e47-b235-71ce7637eb76" class="">(3)线程2将该数据修改为A；</p><p id="ad791a5e-d241-4395-a915-f04bc69e3c76" class="">(4)线程1对数据进行CAS操作</p><p id="8caad575-1526-4a1f-82eb-061fe3fb2305" class="">在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。</p><p id="88ceaa41-bf4a-4ab7-aadf-580f19d877eb" class="">在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。</p><p id="82ca7f7d-1508-46cd-b86d-99fd641f81ef" class="">对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p></details></li></ul></details></li></ul><ul id="0b4c150f-4c76-47c0-8db6-42478a9771a0" class="toggle"><li><details open=""><summary><strong>2、高竞争下的开销问题</strong></summary><p id="ecab7f3c-cd3e-40a2-8b99-0db4eb64ddde" class="">在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。</p></details></li></ul><ul id="c6b6dfa4-a615-458e-b6cd-4af7f7671021" class="toggle"><li><details open=""><summary><strong>3、功能限制</strong></summary><p id="8936e26e-b2e0-4a8b-93a7-ab8f24bec821" class="">CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，这意味着：(1)原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；(2)当涉及到多个变量(内存值)时，CAS也无能为力。</p><p id="d802d052-d30c-43fc-a1cb-05f63035eecf" class="">除此之外，CAS的实现需要硬件层面处理器的支持，在Java中普通用户无法直接使用，只能借助atomic包下的原子类使用，灵活性受到限制。</p></details></li></ul></details></li></ul><p id="64fec04d-5655-4c70-b4fd-0732d4769f67" class="">
</p></details></li></ul></div><p id="2fdbe2ea-16c4-4f69-bac0-71ec8c9319b4" class="">
</p></details></li></ul><p id="ccf3f8bf-b63c-4c54-8790-8ce264ed69af" class="">
</p></details></li></ul><ul id="79f264c2-7126-4196-95ba-fb4bd6a11800" class="toggle"><li><details open=""><summary>两者开销成本：</summary><p id="da9448f8-faa1-447b-a376-97118f12f43e" class="">两次线程上下文切换</p><p id="962efadf-28e0-4550-a243-bf79f6be3512" class="">当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p><ul id="9e71f327-e872-43c6-b4c4-e77d93685ba5" class="toggle"><li><details open=""><summary><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</summary><figure id="ed0af3ca-112c-4ff6-97b6-13a1473eb74e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2013.png"><img style="width:480px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2013.png"/></a></figure><p id="08152e34-2063-4750-88fe-d80be351d63d" class="">互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p><p id="b97f7ee2-1479-4082-a789-bed3d7aa8ef7" class=""><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在<strong>合适的时机</strong>唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。</p><ul id="ef8af630-66ff-438a-8bc9-4a2dbed1a54e" class="toggle"><li><details open=""><summary>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的<mark class="highlight-red"><strong>性能开销成本</strong></mark>。</summary><ul id="d4da4f31-2bfb-409f-81f6-29424e8f33d9" class="toggle"><li><details open=""><summary><mark class="highlight-red"><strong>两次线程上下文切换的成本</strong></mark></summary><ul id="47dac712-69f1-41f4-818e-ce62d96197ea" class="bulleted-list"><li style="list-style-type:disc">当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li></ul><ul id="59605f02-ea90-4cd4-9ba1-f9c4ac3a287c" class="bulleted-list"><li style="list-style-type:disc">接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li></ul></details></li></ul><ul id="4c58657a-1e3d-40ba-ba71-9a479e254b48" class="toggle"><li><details open=""><summary>线程的上下文切换的是什么？</summary><ul id="f5f33b1f-32b6-4625-85a5-9a4e1d9604f3" class="toggle"><li><details open=""><summary>当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></summary></details></li></ul><p id="2cb17e12-e97b-4e4c-b5e2-eb9d21df19ac" class="">上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p></details></li></ul><p id="e40413d6-f29b-4f62-bfb4-79d7a8d4252d" class="">所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p></details></li></ul></details></li></ul><ul id="3ce11b55-f748-438e-bf70-6e2fea39e524" class="toggle"><li><details open=""><summary><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</summary><p id="6d783752-323f-4838-99a3-aa2e4ded9632" class="">自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><ul id="91374b43-641b-43af-ab42-f027c7b2b178" class="toggle"><li><details open=""><summary>一般加锁的过程，包含两个步骤：</summary><ul id="78f2e534-e327-40c3-ae96-ca7f7f223076" class="bulleted-list"><li style="list-style-type:disc">第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li></ul><ul id="42184a58-b6ac-4d20-a80b-4402e1d1c78e" class="bulleted-list"><li style="list-style-type:disc">第二步，将锁设置为当前线程持有；</li></ul></details></li></ul><p id="de8018f5-7f66-4c5d-8e8f-10b1767d989f" class="">CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p id="45981ef1-3384-4736-a7a1-cad897ce8965" class="">使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p><p id="26474dd0-b6cb-4277-8b02-c97babf4c6c6" class="">自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p><p id="71afe576-676b-4fd8-bb49-5a159c062d07" class="">自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p></details></li></ul><ul id="f6c647cf-841d-486c-9c27-e50f4d21c280" class="toggle"><li><details open=""><summary>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</summary></details></li></ul><ul id="26c313a9-22e2-42f1-991b-a6221b51d5cd" class="toggle"><li><details open=""><summary>应用场景-根据成本选择：</summary><p id="766ba719-7d4f-4038-9ba5-d4fb49358a9d" class="">自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。
互斥锁相反</p></details></li></ul></details></li></ul></details></li></ul><ul id="6df03d50-28ac-4060-9f9d-5a8da0637f51" class="toggle"><li><details open=""><summary>读写锁 - 角色模式</summary><p id="d5a6412e-9809-4442-a34e-4bb964be3633" class="">允许多个线程同时读共享数据，而对写操作是互斥的。</p><ul id="557588d0-4485-4c3b-aa0a-e55a4b9ed573" class="toggle"><li><details open=""><summary>读写锁的工作原理是：</summary><ul id="b1b76f63-62b5-4a5a-a2d7-057ca224cd43" class="bulleted-list"><li style="list-style-type:disc">当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li></ul><ul id="55418f2a-9206-4464-bb2b-55a193d50153" class="bulleted-list"><li style="list-style-type:disc">但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul></details></li></ul><ul id="0ae96edb-05fd-4ec6-bfa8-420fc8b8e56d" class="toggle"><li><details open=""><summary>读写锁 - 应用场景</summary><p id="fe5b5533-f21e-4e7d-85d4-4792fbc9489f" class="">读写锁适<mark class="highlight-red">用于能明确区分读操作和写操作的场景</mark>(例如 数据库)</p><p id="a33dc559-1570-4510-9c50-b079ef2970a8" class="">所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p><ul id="1f0924a7-6879-4615-b4ce-81f26e302d17" class="toggle"><li><details open=""><summary><strong>读写锁在</strong><mark class="highlight-red"><strong>读多写少</strong></mark><strong>的场景，能发挥出优势</strong>。另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</summary><ul id="2b8567ce-89bc-4896-89a1-886f3d8c035d" class="toggle"><li><details open=""><summary>读优先锁</summary><p id="8d59acc6-0c4d-492b-adb3-1c4183b72970" class="">读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p><figure id="cedef8c6-4ab6-4c8b-9fb0-42e68969243e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2014.png"><img style="width:720px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2014.png"/></a></figure></details></li></ul><ul id="bda903cb-70b1-44a0-b1f0-558f0f71c484" class="toggle"><li><details open=""><summary>写优先锁</summary><ul id="7ae68e31-31b9-404f-b634-e87778678060" class="toggle"><li><details open=""><summary>而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：</summary></details></li></ul><figure id="c2a6f4da-48fc-4911-a40a-477bf6bcf156" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2015.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2015.png"/></a></figure></details></li></ul><p id="a904b456-5bb9-4a49-9eb0-cacb93674cb1" class="">读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p><p id="af4b4265-90e0-4c7f-a716-fa620000b7f4" class="">写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p><ul id="d635fd6b-a22e-4844-a1e4-9eea906bb0cb" class="toggle"><li><details open=""><summary>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，<mark class="highlight-red"><strong>搞个「公平读写锁」。</strong></mark></summary><p id="5cd00b49-c9ed-45b6-9f2f-fdf86ded2db4" class="">公平读写锁比较简单的一种方式是<strong>：用队列把获取锁的线程排队，不管是写线程还是读线程都按照</strong><mark class="highlight-red"><strong>先进先出</strong></mark><strong>的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p></details></li></ul><p id="72da2fc0-e611-4169-8d56-6f2410833a47" class="">互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p></details></li></ul></details></li></ul><ul id="98e1fece-8c24-433e-bf30-15dcdefadf70" class="toggle"><li><details open=""><summary>如何实现读写锁</summary><p id="146a3186-b4a2-4695-920f-ad7dee91f726" class=""><a href="https://www.cnblogs.com/DarrenChan/p/8619476.html"><strong>阿里巴巴面试之利用两个int值实现读写锁</strong></a></p><ul id="326b25d1-cca7-40d7-8ecf-5354f8e5bab0" class="toggle"><li><details open=""><summary>读锁饥饿问题</summary></details></li></ul><p id="aef66ff4-92d0-4f53-b8e7-f70ba9a9ffed" class="">
</p></details></li></ul></details></li></ul><ul id="0820e44c-762c-4217-a68a-3242fe57ee33" class="toggle"><li><details open=""><summary><a href="https://www.cnblogs.com/kismetv/p/10787228.html">乐观锁与悲观锁</a> - 思想</summary><p id="2e71f7a6-a65c-4d41-b2fd-7bc6a8915755" class="">乐观锁和悲观锁是<strong>两种思想</strong>，使用非常广泛，不局限于某种编程语言或数据库。</p><ul id="60fb203c-4a88-44a5-a9e5-8d3390eeb433" class="toggle"><li><details open=""><summary>悲观锁：</summary><p id="fecfa5d8-04ed-4be8-b28a-c2725eb91f26" class="">前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p id="c3c8925e-f3d4-44dd-8223-fa80cc374423" class="">悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以</strong><mark class="highlight-red"><strong>访问共享资源前，先要上锁</strong></mark><mark class="highlight-red">。</mark></p><p id="af4bc533-9b93-4a98-9c76-8f462787fd6d" class="">相反，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p></details></li></ul><ul id="5523cae0-4e5d-4abf-b26c-5f3b785b71ca" class="toggle"><li><details open=""><summary>乐观锁：</summary><p id="5d4a77f7-6f64-4e32-91ba-8027075b7f70" class="">假定冲突的概率很低，它的工作方式是：<mark class="highlight-red">先修改完共享资源，再验证这段时间内有没有发生冲突，</mark>如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。(CMU 数据库好像讲过)</p><p id="7571df59-a449-4a62-b2db-5d746b134fd0" class="">放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p><p id="701c23c3-50c4-437b-860e-01c8c5fff236" class="">另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p></details></li></ul><ul id="b609bb06-9ea3-4c99-b932-fcd2af7f2d55" class="toggle"><li><details open=""><summary>实现方式</summary><ul id="53cda420-73f0-496a-970f-1fca48cc4454" class="toggle"><li><details open=""><summary>悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。</summary></details></li></ul><ul id="ce8a6fd7-b914-49a8-a91f-ea5355d71fc0" class="toggle"><li><details open=""><summary>乐观锁的实现方式主要有两种：</summary><p id="922c442f-86eb-427f-a400-9c1e3bceb08f" class="">CAS机制和版本号机制（类似mvcc）</p><div><ul id="b0b1c944-5cc3-45a4-b5d9-d6e52338c896" class="toggle"><li><details open=""><summary>CAS（Compare And Swap）</summary><ul id="c0fa0353-6b4b-4a12-90f2-d1a6de90f962" class="toggle"><li><details open=""><summary>CAS操作包括了3个操作数：</summary><ul id="cc3e5e38-7319-468b-ab74-996233b6293b" class="bulleted-list"><li style="list-style-type:disc">需要读写的内存位置(V)</li></ul><ul id="6b61054d-efc4-4ecb-aa5e-b3f57a90ea7a" class="bulleted-list"><li style="list-style-type:disc">进行比较的预期值(A)</li></ul><ul id="65266c25-c544-4179-9b44-fe946a2a5a59" class="bulleted-list"><li style="list-style-type:disc">拟写入的新值(B)</li></ul></details></li></ul><ul id="9c70055b-5851-45e4-bf26-35774f4aa0df" class="toggle"><li><details open=""><summary><mark class="highlight-red">CAS操作逻辑如下</mark>：</summary><p id="38b41903-9443-453a-bf77-e950a39cda1b" class=""><mark class="highlight-red">如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作</mark>。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p></details></li></ul><p id="9a7f26f7-c949-4261-9561-13b51f0f2341" class="">这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？答案是：CAS是由CPU支持的原子操作，其<mark class="highlight-red">原子性是在硬件层面进行保证的</mark>。</p><ul id="7fdcfe63-c6e7-4b63-84ac-4055911d9265" class="toggle"><li><details open=""><summary>缺点</summary><ul id="73b329f5-ae14-4d0b-9638-97bc81455dac" class="toggle"><li><details open=""><summary><strong>1、</strong><mark class="highlight-red"><strong>ABA问题</strong></mark></summary><ul id="aae2700c-0c3d-461e-a1e1-0816028c0664" class="toggle"><li><details open=""><summary><a href="https://www.zhihu.com/question/23281499/answer/1029690466">定义：</a></summary><p id="8f532197-8cb6-42fd-b49a-9ac9a564956d" class="">ABA的场景出现时，预期值和旧值相同会让线程以为这个值没有被改变过，然而“值相同=没有被改变过”无法成立，即使第二个线程确确实实改过这个值，只不过又改回来了。“值曾经发生过改动”这个事件就无法被观测到。对于需要跟踪值的改变过程（比如记录值改变的次数）的场景来说ABA问题就是致命的。</p></details></li></ul><ul id="1ce6d968-c55b-4091-adb6-100941eec7a9" class="toggle"><li><details open=""><summary>假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</summary><p id="d88cad06-3b7b-4a4f-be4c-0fcee6e3c15c" class="">(1)线程1读取内存中数据为A；</p><p id="e92933a0-b3bc-423d-a878-860a9d2f1bc9" class="">(2)线程2将该数据修改为B；</p><p id="bb92222c-57d4-4e47-b235-71ce7637eb76" class="">(3)线程2将该数据修改为A；</p><p id="ad791a5e-d241-4395-a915-f04bc69e3c76" class="">(4)线程1对数据进行CAS操作</p><p id="8caad575-1526-4a1f-82eb-061fe3fb2305" class="">在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。</p><p id="88ceaa41-bf4a-4ab7-aadf-580f19d877eb" class="">在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。</p><p id="82ca7f7d-1508-46cd-b86d-99fd641f81ef" class="">对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p></details></li></ul></details></li></ul><ul id="0b4c150f-4c76-47c0-8db6-42478a9771a0" class="toggle"><li><details open=""><summary><strong>2、高竞争下的开销问题</strong></summary><p id="ecab7f3c-cd3e-40a2-8b99-0db4eb64ddde" class="">在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。</p></details></li></ul><ul id="c6b6dfa4-a615-458e-b6cd-4af7f7671021" class="toggle"><li><details open=""><summary><strong>3、功能限制</strong></summary><p id="8936e26e-b2e0-4a8b-93a7-ab8f24bec821" class="">CAS的功能是比较受限的，例如CAS只能保证单个变量（或者说单个内存值）操作的原子性，这意味着：(1)原子性不一定能保证线程安全，例如在Java中需要与volatile配合来保证线程安全；(2)当涉及到多个变量(内存值)时，CAS也无能为力。</p><p id="d802d052-d30c-43fc-a1cb-05f63035eecf" class="">除此之外，CAS的实现需要硬件层面处理器的支持，在Java中普通用户无法直接使用，只能借助atomic包下的原子类使用，灵活性受到限制。</p></details></li></ul></details></li></ul><p id="64fec04d-5655-4c70-b4fd-0732d4769f67" class="">
</p></details></li></ul></div><ul id="8192b159-e269-42c4-90a4-32fd025a9806" class="toggle"><li><details open=""><summary>版本号机制</summary><p id="2558144d-21b8-4e7b-b191-67c22e5a7590" class="">
</p></details></li></ul></details></li></ul></details></li></ul><ul id="1185c953-1ab1-4478-8eed-206c9005de38" class="toggle"><li><details open=""><summary>优缺点和适用场景</summary><p id="40609472-7c87-482e-9568-265407b26314" class="">乐观锁和悲观锁并没有优劣之分，它们有各自适合的场景；下面从两个方面进行说明。</p><ul id="be7e8219-78bc-4e2e-ac06-056ef14002c9" class="toggle"><li><details open=""><summary>1 功能限制</summary><p id="73182c43-6260-4513-b2c7-b1e36b03a2da" class="">与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</p><p id="a489de9d-df08-4d24-b045-f1093740def4" class="">例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p></details></li></ul><ul id="149a5720-6ef9-486b-bacb-037765fe6289" class="toggle"><li><details open=""><summary>2 竞争激烈程度</summary><p id="6f9cf7b0-a5ff-4a59-af4e-8165dc1e2b18" class="">如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</p><ul id="55fb58d8-a8fb-4410-8bda-2bab9ef4aadc" class="bulleted-list"><li style="list-style-type:disc">当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</li></ul><ul id="802487db-e59c-4751-b919-861a24cd035c" class="bulleted-list"><li style="list-style-type:disc">当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</li></ul></details></li></ul></details></li></ul><ul id="bd616b22-9272-424e-b8ab-c7cbd7c2e8a2" class="toggle"><li><details open=""><summary>场景例子：在线文档。</summary><p id="1b6ce033-3e08-4e91-a04e-f4786e8dfbd1" class="">我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p><p id="a4485a28-a82f-432c-95f1-fa495e0f0ca7" class="">那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p><p id="1edffaeb-9b53-4f5e-8504-cea47a01df3e" class="">怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p><p id="9ffc05f4-c93a-4d81-8864-fd91289af4bf" class="">服务端要怎么验证是否冲突了呢？通常方案如下：</p><ul id="245446c6-2675-43ee-a351-e13fec90e489" class="bulleted-list"><li style="list-style-type:disc">由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li></ul><ul id="d809c30e-13d6-46fc-aa72-304500f479ba" class="bulleted-list"><li style="list-style-type:disc">当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。</li></ul><p id="d60136d4-2a2d-4c9a-a325-8841da134d38" class="">实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p></details></li></ul><p id="9e89f7d2-e26a-48bb-85f5-f019a05dbf39" class="">乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p></details></li></ul><p id="e8917f5f-6f04-4f4b-b96c-6b79fd63b8ca" class="">
</p><ul id="07ad7c11-1f6d-4b92-adae-b1930aa4b229" class="toggle"><li><details open=""><summary>总结（待整理）</summary><table id="729813ad-deb6-40be-8843-e24efb413d80" class="simple-table"><tbody><tr id="634c0437-0889-4163-b1f0-ef5946a67033"><td id="mVFP"></td><td id="&lt;]q&lt;">互斥锁</td><td id="&lt;qr_">自旋锁</td></tr><tr id="f4ff7881-3126-426f-ab0e-4ccf2b1ab153"><td id="mVFP">加锁失败</td><td id="&lt;]q&lt;">进行线程切换</td><td id="&lt;qr_">不会主动产生线程切换，而是一直忙等待，直到获取到锁</td></tr><tr id="a7c55812-ccb3-434c-8ee1-ec72fcd888e2"><td id="mVFP">加锁失败开销</td><td id="&lt;]q&lt;">上下文切换</td><td id="&lt;qr_">CPU占用</td></tr></tbody></table><p id="bc76ef24-dbf0-4cf7-98e6-7cf101fd785b" class="">开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p><p id="73be2701-676b-4c86-a4ee-6d85cad8c277" class="">如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p><p id="e75b559c-c1b8-4f3e-977c-f4475429a7b1" class=""><mark class="highlight-red">读写锁</mark>允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了<mark class="highlight-red">公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁</mark>，这样便保证了某种线程不会被饿死，通用性也更好点。读写锁可以根据场景来选择互斥锁、自旋锁这两种锁其中的一个进行实现。</p><p id="215fe87b-9f86-461f-becf-0f017914c69c" class="">另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p><p id="0f318459-9d18-4337-98f2-8dea10deb49e" class="">相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><p id="1565d6d8-ae16-455c-9cd6-f5a6f1c8b7be" class="">但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p><p id="1167d908-f43f-4ccb-a2c2-10691580307c" class="">不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p></details></li></ul></details></li></ul></details></li></ul><ul id="648a6f2b-5c68-40c2-95de-84b833714d2e" class="toggle"><li><details open=""><summary><strong>临界区(CcriticalSection)</strong></summary><p id="d5cd98df-217b-4ebc-ba6f-a47b8a71d2f7" class="">通过对多线程的串行化来<strong>访问公共资源或一段代码，速度快，适合控制数据访问</strong>。</p><p id="6f39321b-909f-4f57-bc58-29114ab36d28" class="">在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被<mark class="highlight-red">挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</mark></p><p id="9a74c3d4-6cf3-42ec-9a7c-cf384a105b53" class="">不可以跨进程，忘记解锁会无限等待，要么存在要么没有，多线程访问独占性共享资源。</p><p id="8ecb127d-4026-4471-bb7c-8ebecf21e574" class="">此为效率最高，而为什么是效率最高，字节面试的时候就问了这个问题。临界区的效率最高是因为它不用陷入内核，</p><ul id="54cb3e6c-936a-4b91-8660-c76f72f0dca1" class="toggle"><li><details open=""><summary>原子操作（例如一个单一的全局变量）， 用户模式</summary><p id="0d6db68d-848a-49ce-a1b1-62b0542549e1" class="">当然如果你要寻求更高效的同步方式，应该用原子锁，原子锁的效率是临界区的5倍左右</p></details></li></ul><p id="d2cadd30-19d0-44e4-8c62-1f0397617e87" class="">临界区对应着一个<code>CcriticalSection</code>对象，当线程需要访问保护数据时，调用<code>EnterCriticalSection</code>函数；当对保护数据的操作完成之后，调用<code>LeaveCriticalSection</code>函数释放对临界区对象的拥有权。</p></details></li></ul><ul id="afce8250-5ce3-48f8-aec2-38fa91aff398" class="toggle"><li><details open=""><summary><strong>互斥量（Mutex Semaphore（又名Mutex））</strong></summary><p id="7ac90a8a-0487-4b21-b7f8-6303bf91b736" class="">互斥与临界区很相似，但是使用时相对复杂一些（<mark class="highlight-red">互斥量为内核对象</mark>），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。(互斥量就是互斥锁？)</p><ul id="20045142-293e-43c2-bd17-40d17fdfdfed" class="toggle"><li><details open=""><summary><strong>互斥量</strong>：</summary><p id="58b5a029-5988-4a0f-98af-d24919dfbfd4" class="">2、互斥量:为协调共同对一个共享资源的单独访问而设计的。</p><ul id="036f1ca1-b2de-4f24-86c9-485a97b5f084" class="toggle"><li><details open=""><summary>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</summary></details></li></ul><ul id="71f43818-6b9a-456d-970c-0fdaea9a0f10" class="toggle"><li><details open=""><summary>可以跨进程，忘记解锁会自动释放，要么存在要么没有。</summary></details></li></ul><ul id="df9938c2-a8a2-409d-9ffd-fb538d645099" class="toggle"><li><details open=""><summary>怎么表示互斥量</summary></details></li></ul></details></li></ul></details></li></ul><ul id="b91f662b-01b1-4349-a563-ea1a3d3e803e" class="toggle"><li><details open=""><summary>两者区别</summary><ul id="0a345641-6147-4824-a777-4cc64bff18c7" class="toggle"><li><details open=""><summary>临界区</summary><p id="db9b1ccc-97cf-439c-adf5-cc6b657d29a6" class="">临界区用来保证在同一时刻只有一个线程可以访问到资源，对于临界区进行操作的函数有两个：</p><pre id="a81f6c2a-c1ab-4fa6-8436-0976a70be069" class="code code-wrap"><code>EnterCriticalSection();
LeaveCriticalSection();</code></pre><p id="247ba1f9-1618-4550-b30f-9ae0a35e61fd" class="">临界区最大的特色是其同步速度很快，但是其只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</p></details></li></ul><ul id="1e6af632-5866-40a2-9bf0-044affb936c7" class="toggle"><li><details open=""><summary>互斥量</summary><p id="297a5157-33dc-4c48-b3c5-a68ab4411d67" class="">互斥量和临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，互斥量比临界区负责，并且互斥量是可以命名的，因此互斥量不仅仅可以用于同一应用程序不同线程中资源的同步，也可以用于不同应用程序的线程之间实现对资源的同步。</p><p id="0c8d9a54-179b-4a01-bfab-fd4c4647b6b7" class="">因此互斥量可以在整个系统中被任意进程的任意线程访问到，但它严格限定只有获取了互斥量的线程才能释放该互斥量。</p></details></li></ul></details></li></ul><p id="7627dc0e-8ef7-4f07-91fd-3c7f9d03e7d2" class="">
</p><p id="b4bcd2af-e850-43ba-872b-db60926f9a74" class="block-color-orange_background">互斥带来的问题</p><ul id="69a7da0e-d525-4aa2-a494-fbdc0a3bf4e2" class="toggle"><li><details open=""><summary>饥饿</summary><p id="bf748522-a42b-48ed-8940-d5b246b5f04c" class="">饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p><p id="580d4e1c-2732-4dad-9dfb-124a6fd6a27b" class="">
</p></details></li></ul><ul id="d753036c-4d53-4d0a-98ef-96f61cfd60ef" class="toggle"><li><details open=""><summary><mark class="highlight-red">死锁</mark></summary><p id="7c74532b-0dfe-46a9-a47a-bcb85f849b20" class="">例子：两个进程红蓝钥匙开门，有一定几率出现死锁</p><ul id="081d94c9-2709-4ad7-b64a-ad633e6b07e3" class="toggle"><li><details open=""><summary>定义</summary><p id="018489d0-d0f3-4360-89cd-bdd750e61eed" class="">一种阻塞现象</p><p id="6c063499-03b2-4306-9eff-ff87c052229c" class=""><mark class="highlight-yellow_background">当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，</mark><mark class="highlight-red">这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。</mark></p></details></li></ul><ul id="04aba248-9697-46eb-aa00-f6f984eecf15" class="toggle"><li><details open=""><summary>为什么会出现</summary><p id="a1a304e3-b743-45a0-85f7-bf969aef1e12" class="">资源数量有限、锁和信号量错误使用</p></details></li></ul><ul id="b6f7c2c6-8b58-4606-8456-53beda692585" class="toggle"><li><details open=""><summary>四个必要条件（死锁只有同时满足以下四个条件才会发生）：</summary><ul id="edd1e7aa-52b6-43dd-ba1c-f47add70cf36" class="toggle"><li><details open=""><summary>互斥条件：</summary><ul id="756c61f1-69b0-4dce-b016-f6209ca16a11" class="toggle"><li><details open=""><summary><mark class="highlight-yellow_background">是指多个线程不能同时使用同一个资源。</mark></summary></details></li></ul><ul id="3392d66a-1991-4081-976d-70c86f669779" class="toggle"><li><details open=""><summary>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</summary></details></li></ul><figure id="745ce2bb-13b7-4461-94aa-27e7f2a1b233" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2016.png"><img style="width:551px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2016.png"/></a></figure><p id="f3f361f4-06a6-44ae-85a2-eb480829b8a0" class="">——只有一副钥匙</p></details></li></ul><ul id="dd964c4f-55c6-480d-8c97-6b54e3e69448" class="toggle"><li><details open=""><summary>持有并等待条件：</summary><ul id="50be7e23-b223-4545-81e9-f193f755976f" class="toggle"><li><details open=""><summary>指<mark class="highlight-red">进程已经保持至少一个资源</mark>，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</summary></details></li></ul><p id="2b56d3cc-7b6d-4c4b-a187-54197628500b" class="">——拿着红钥匙的人在没有归还红钥匙的情况下，又提出要蓝钥匙</p><figure id="eefc5ec4-e10f-4ff0-92bc-2dff0ab253b6" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2017.png"><img style="width:561px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2017.png"/></a></figure></details></li></ul><ul id="a9449614-cd93-403a-af48-972985cdd7eb" class="toggle"><li><details open=""><summary>不剥夺条件：</summary><ul id="d8b6b79a-7da1-4bde-9fa2-93f59b7e8365" class="toggle"><li><details open=""><summary>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</summary></details></li></ul><p id="7533aca3-8ee4-4062-9570-862b24205a38" class="">——人除非归还了钥匙，不然一直占用着钥匙</p><figure id="57668beb-82e9-417e-ae1a-5e6948bdad8e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2018.png"><img style="width:551px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2018.png"/></a></figure></details></li></ul><ul id="b0c9d8f5-1fec-4664-9e76-dd998e53c15a" class="toggle"><li><details open=""><summary>环路等待条件：</summary><p id="491ee57c-d521-401e-b831-a9ac35738859" class=""><mark class="highlight-yellow_background">在死锁发生的时候，</mark><mark class="highlight-red">两个线程获取资源的顺序构成了环形链</mark><mark class="highlight-yellow_background">。</mark></p><ul id="5f2fe181-2bc3-42cc-bfef-d39f51c094aa" class="toggle"><li><details open=""><summary>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</summary></details></li></ul><p id="18174e7d-57c9-463a-9fef-bf5a500a5719" class="">——拿着红钥匙的人在等蓝钥匙，同时那个拿着蓝钥匙的人在等红钥匙</p><figure id="8acf79b0-c49e-442e-af3b-ff43a8159358" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2019.png"><img style="width:421px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2019.png"/></a></figure></details></li></ul></details></li></ul><ul id="87487e30-8965-48bd-8016-77626bfabfc2" class="toggle"><li><details open=""><summary><a href="https://www.cnblogs.com/xiaolincoding/p/14604726.html">代码模拟</a>Show me the code</summary><ul id="0f94dbae-15bb-4a2a-bcdb-a3fc3cc20ad8" class="toggle"><li><details open=""><summary>使⽤ pstack + gdb ⼯具来定位死锁问题</summary><p id="77bfba76-fbe9-46a2-bfa7-153f4b4bad29" class=""><code>pstack </code>命令可以显示每个线程的栈跟踪信息（函数调⽤过程），它的使⽤⽅式也很简单，只需要 pstack &lt;pid&gt; 就可以了。</p><p id="562b59ca-8f26-4248-b799-52abb99fda81" class="">那么，在定位死锁问题时，我们可以多次执⾏ <code>pstack </code>命令查看线程的函数调⽤过程，<strong>多次对⽐结果，确认 哪⼏个线程⼀直没有变化，且是因为在等待锁，那么⼤概率是由于死锁问题导致的。</strong></p><p id="53b0d3fd-4048-43f9-b808-3c406b9b5f4e" class="">
</p></details></li></ul></details></li></ul><ul id="a694abfe-eeae-47ec-9b93-c4cc8b7d4e91" class="toggle"><li><details open=""><summary>避免方法：破坏四个必要条件之一</summary><ul id="f66efa88-e60c-4198-9371-36a588a6b715" class="toggle"><li><details open=""><summary>ref1 <a href="https://zhuanlan.zhihu.com/p/26945588">zhihu</a>:  </summary><ul id="310d3a9c-f051-487b-8770-bbd56faa3612" class="toggle"><li><details open=""><summary>前三个：独占锁特点 。<a href="https://www.jianshu.com/p/44125bb12ebf">所以，面对如何避免死锁这个问题，我们只需要这样回答</a>！：  在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</summary></details></li></ul></details></li></ul><ul id="d93e4b77-ad3f-4df2-9f9d-a7aa2972f2f4" class="toggle"><li><details open=""><summary>ref2 小林coding</summary><ul id="df2ac8e8-7b33-48ea-b62f-1aa57739af1f" class="toggle"><li><details open=""><summary>避免死锁问题就只需要破环其中⼀个条件就可以，最常⻅的并且可⾏的就是使⽤<mark class="highlight-red"><strong>资源有序分配法</strong></mark>，来 破环环路等待条件。</summary><p id="4969a4c8-34c9-42af-8341-f8ae3052409e" class="">线程 A 和 线程 B 获取资源的顺序要⼀样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候， 线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，<strong>线程 A 和 线程 B</strong><mark class="highlight-red"><strong> 总是以相同的顺 序申请⾃⼰想要的资源。</strong></mark>
我们使⽤资源有序分配法的⽅式来修改前⾯发⽣死锁的代码，我们可以不改动线程 A 的代码。 我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。
所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p><figure id="f993fea4-4bda-494a-a7c9-9205aa9e0e63" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2020.png"><img style="width:528px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2020.png"/></a></figure></details></li></ul><p id="4dfbcb78-ae30-49e6-80e7-c6e17d2fbc89" class="">
</p></details></li></ul></details></li></ul><ul id="ccc58cb8-3d84-4a49-ad6a-942d35cdbb74" class="toggle"><li><details open=""><summary><strong>如果发生死锁了怎么办？</strong></summary><ul id="7852ec6d-7bca-48ec-800f-de03ac3777ec" class="bulleted-list"><li style="list-style-type:disc">死锁检测：发生死锁之前总归需要先检测到死锁吧，不然怎么进行接下来的操作？可以通过检测有向图中是否存在环来检测，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问到了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li></ul><ul id="30b13221-1918-4216-b8af-e02bc04d490b" class="toggle"><li><details open=""><summary>死锁恢复：从下到上逐渐变态。。。</summary><ul id="777b46fd-3e57-42c4-a7ce-dc9df1e32b7b" class="bulleted-list"><li style="list-style-type:disc">撤销进程法： <ul id="997bbff2-edcb-4839-8b0c-38ee9c6a7ba2" class="bulleted-list"><li style="list-style-type:circle">1) 撤消陷于死锁的全部进程；</li></ul><ul id="e82dcf78-2605-4be3-999b-e74c69270fd4" class="bulleted-list"><li style="list-style-type:circle">2) 逐个撤消陷于死锁的进程，直到死锁不存在；</li></ul></li></ul><ul id="1338b576-1f80-4967-b15a-cc1c3d3e93b4" class="bulleted-list"><li style="list-style-type:disc">资源剥夺法： <ul id="ce62955e-f6a0-47ff-8980-fc910383e677" class="bulleted-list"><li style="list-style-type:circle">3) 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失；</li></ul><ul id="90b1a8b8-4cdb-4697-b81f-e5ac5489a397" class="bulleted-list"><li style="list-style-type:circle">4) 从另外的进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li></ul></li></ul><ul id="c53860ca-15d7-4ac5-b388-491d830e6164" class="bulleted-list"><li style="list-style-type:disc">鸵鸟<a href="https://www.notion.so/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>，直接不管！</li></ul></details></li></ul></details></li></ul></details></li></ul><p id="6083bfb7-eadc-4ecf-970f-736c973a5197" class="">
</p><ul id="4106481f-e0eb-4288-8334-2998b64876b6" class="toggle"><li><details open=""><summary><mark class="highlight-red">四种常见</mark><mark class="highlight-red"><a href="https://www.cnblogs.com/xiaolincoding/p/13346658.html">算法</a></mark></summary><div><ul id="9fbab661-b801-4bf5-a1fc-a0686fc849e9" class="toggle"><li><details open=""><summary>生产者消费者 - 同步问题</summary><figure id="f84b6d69-9c43-4d89-9b2f-758a419e9c06" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2021.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2021.png"/></a></figure><ul id="aea73b09-a57e-429b-8910-815a2ccea49e" class="toggle"><li><details open=""><summary>生产者-消费者问题描述：</summary><p id="b9fe58d3-105a-4ba2-bbfd-81e04ec95cfb" class="">定义：某个模块（函数等〉负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等)。产生数据的模块，就形象地称为生产者;而处理数据的模块，就称为消费者。</p><p id="1d2dda89-abbf-40fc-87e0-e9217454a8f3" class="">通常：</p><ul id="30356be3-5533-4e04-8a27-ee068c19a087" class="bulleted-list"><li style="list-style-type:disc"><strong>生产者</strong>在生成数据后，放在一个缓冲区中；</li></ul><ul id="8c6f3005-1abd-42ac-accd-b77ce9ff1058" class="bulleted-list"><li style="list-style-type:disc"><strong>消费者</strong>从缓冲区取出数据处理；</li></ul><ul id="66641dfa-327e-4853-b7a6-df12676f81da" class="bulleted-list"><li style="list-style-type:disc">任何时刻，<strong>只能有一个</strong>生产者或消费者可以访问缓冲区；</li></ul></details></li></ul><ul id="c5dd4a60-5a61-4ccd-a32f-d6c800eaf73b" class="toggle"><li><details open=""><summary>我们对问题分析可以得出：</summary><ul id="3dd3faac-8ab3-428f-afc5-94cf9ada25fe" class="bulleted-list"><li style="list-style-type:disc">任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，<strong>需要互斥</strong>；</li></ul><ul id="f87c97f3-5bbb-47d4-94df-a0ba19b907cd" class="bulleted-list"><li style="list-style-type:disc">缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者<strong>需要同步</strong>。</li></ul></details></li></ul><ul id="c346b0e2-4a3b-4649-8fca-3aec12541077" class="toggle"><li><details open=""><summary>那么我们需要三个信号量，分别是：</summary><ul id="d781db97-d110-4a56-9943-62cd4e89e958" class="bulleted-list"><li style="list-style-type:disc">互斥信号量 <code>mutex</code>：用于互斥访问缓冲区，初始化值为 1；</li></ul><ul id="90343ffb-125c-44fe-9f5c-806359d48b23" class="bulleted-list"><li style="list-style-type:disc">资源信号量 <code>fullBuffers</code>：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；</li></ul><ul id="b3fba033-a2ee-4648-8aa8-c3851821b242" class="bulleted-list"><li style="list-style-type:disc">资源信号量 <code>emptyBuffers</code>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；</li></ul></details></li></ul><ul id="375627c9-96b7-4cfb-b7ef-4e8da46a3902" class="toggle"><li><details open=""><summary><mark class="highlight-red">具体的实现代码</mark>：</summary><ul id="88c48bb3-4897-42a3-b75e-daebe07b8d0f" class="toggle"><li><details open=""><summary>伪代码：</summary><pre id="76ffc480-fe7f-493b-b8f6-6b4cbe083386" class="code"><code>mutex = 1;
empty = N;
full = 0;

void Producer() {
    P(empty); // 生产者生产一个产品，消耗一个缓冲区 
    P(mutex);
    ....      // 临界区
    V(mutex);
    V(full); // 产品数量加1
}

void Consumer() {
    P(full); // 消费者消耗一个产品，释放一个缓冲区
    P(mutex); // 临界区上锁
    ....
    V(mutex); // 临界区锁释放
    V(empty); // 增加一个缓冲区
}


void P(S){
    S--;
    if(S &lt; 0) block();  // 如果小于0，代表资源没了
}

void V(S){
    S++;
    if(S &lt;= 0) wakeUp(); // 如果小于等于0，代表有进程仍然在等待，通知他们ok了
}
</code></pre><figure id="d0cb0624-563e-4766-8b3e-2631e5a96589" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80ZjE3ZWUyNC0xNjMzLTRlMGEtYTkzNS02NTkzZmM3ZTA3MzkucG5n?x-oss-process=image/format,png"><img style="width:624px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80ZjE3ZWUyNC0xNjMzLTRlMGEtYTkzNS02NTkzZmM3ZTA3MzkucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul><p id="87980bbc-c20a-489a-9394-66de4814abce" class="">如果消费者线程一开始执行 <code>P(fullBuffers)</code>，由于信号量 <code>fullBuffers</code> 初始值为 0，则此时 <code>fullBuffers</code> 的值从 0 变为 -1，说明缓冲区里没有数据，消费者只能等待。</p><p id="5bef44ec-40aa-4185-a56d-e06b93fcdac4" class="">接着，轮到生产者执行 <code>P(emptyBuffers)</code>，表示减少 1 个空槽，如果当前没有其他生产者线程在临界区执行代码，那么该生产者线程就可以把数据放到缓冲区，放完后，执行 <code>V(fullBuffers)</code> ，信号量 <code>fullBuffers</code> 从 -1 变成 0，表明有「消费者」线程正在阻塞等待数据，于是阻塞等待的消费者线程会被唤醒。</p><p id="cb6d1ab1-8a6d-46b0-a7cb-7c81ad95fb0f" class="">消费者线程被唤醒后，如果此时没有其他消费者线程在读数据，那么就可以直接进入临界区，从缓冲区读取数据。最后，离开临界区后，把空槽的个数 + 1。</p><p id="d27cdd97-6360-4f21-bd71-a8742d3aecc7" class="">
</p></details></li></ul><ul id="cc460c9d-3a9e-47c8-8a4c-1b81a7fd292b" class="toggle"><li><details open=""><summary>改进</summary><p id="ce7facfc-bd60-4565-8d5c-887de8952ee3" class=""><a href="https://www.nowcoder.com/discuss/703119?toCommentId=9723064">https://www.nowcoder.com/discuss/703119?toCommentId=9723064</a></p><p id="a5ddb810-11f7-4512-842c-2c259ec3c851" class="">这个是根据我的项目描述问的，我项目里的生产者是负责监听多个客户端的链接socket和一个监听socket，我回答的是这里可以再开一个线程单独监听监听socket，这样就不会短时间内由于要处理大量的链接请求导致已经建立连接的数据请求无法及时处理</p></details></li></ul></details></li></ul></div><ul id="e9e57e8d-810b-408f-9035-bc6f19119ff5" class="toggle"><li><details open=""><summary>哲学家就餐 - 同步问题</summary><ul id="ae3fd522-7ad6-4502-962e-115b6659567d" class="toggle"><li><details open=""><summary>问题描述</summary><p id="98713962-dd01-4b78-80c7-a4efd6539ef5" class="">时至今日，看我来图解这道题。</p><figure id="02ebe7f5-0648-40d7-b159-5227fc8b3c91" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNzhkMmU1ZS1jMWQzLTRkNTgtODMyMS05ODQwN2ZjYWM4ZTAucG5n?x-oss-process=image/format,png"><img style="width:480px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNzhkMmU1ZS1jMWQzLTRkNTgtODMyMS05ODQwN2ZjYWM4ZTAucG5n?x-oss-process=image/format,png"/></a></figure><p id="b3746e78-01a5-409e-9f36-ed653a36aa9a" class="">哲学家就餐的问题</p><p id="28a0e51a-42fe-4779-a092-721abee40dfa" class="">先来看看哲学家就餐的问题描述：</p><ul id="5d093015-f381-4a68-a956-e27f5f93cb99" class="bulleted-list"><li style="list-style-type:disc"><code>5</code> 个老大哥哲学家，闲着没事做，围绕着一张圆桌吃面；</li></ul><ul id="9829097b-ce70-4f13-8e1d-c8bf5577f715" class="bulleted-list"><li style="list-style-type:disc">巧就巧在，这个桌子只有 <code>5</code> 支叉子，每两个哲学家之间放一支叉子；</li></ul><ul id="d90f67dd-f8f3-4611-bcd2-31bf94f2825e" class="bulleted-list"><li style="list-style-type:disc">哲学家围在一起先思考，思考中途饿了就会想进餐；</li></ul><ul id="eb16c92a-ed29-49ee-b2b6-952dd20197ec" class="bulleted-list"><li style="list-style-type:disc"><strong>奇葩的是，这些哲学家要两支叉子才愿意吃面，也就是需要拿到左右两边的叉子才进餐</strong>；</li></ul><ul id="386f496e-d4e0-47a7-9f40-701d483feea9" class="bulleted-list"><li style="list-style-type:disc"><strong>吃完后，会把两支叉子放回原处，继续思考</strong>；</li></ul></details></li></ul><ul id="b1648de5-e289-4a90-86dd-592102932672" class="toggle"><li><details open=""><summary>方案1</summary><p id="91e1432f-e2d5-4843-838b-2539c11ed5da" class="">我们用信号量的方式，也就是 PV 操作来尝试解决它，代码如下：</p><figure id="97cd10c6-c86f-4bdf-8ed2-6cedd0aae06d" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kYzUzNGFmNS1kNjk0LTQ0MjYtOTRhMC0zMzIxOGY0ZWU2MjgucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kYzUzNGFmNS1kNjk0LTQ0MjYtOTRhMC0zMzIxOGY0ZWU2MjgucG5n?x-oss-process=image/format,png"/></a></figure><p id="164e38e6-89ae-437a-ae41-1ba1821e6cac" class="">上面的程序，好似很自然。拿起叉子用 P 操作，代表有叉子就直接用，没有叉子时就等待其他哲学家放回叉子。</p><figure id="90771a1e-f1bf-4d90-b0f8-ead1985d7967" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kODVkZDNkZS0wNjcyLTQ5M2QtOWZjZS05NjZmOTU4MDgxZmQucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kODVkZDNkZS0wNjcyLTQ5M2QtOWZjZS05NjZmOTU4MDgxZmQucG5n?x-oss-process=image/format,png"/></a></figure><ul id="9e3fc7bf-c995-4eef-b597-86c232a2b993" class="toggle"><li><details open=""><summary>不过，这种解法存在一个极端的问题：假设五位哲学家同时拿起左边的叉子，桌面上就没有叉子了， 这样就没有人能够拿到他们右边的叉子，也就说每一位哲学家都会在 P(fork[(i + 1) % N ]) 这条语句阻塞了，很明显这发生了死锁的现象。</summary></details></li></ul></details></li></ul><ul id="5362fd06-afd9-497b-ae1c-131f5b279aa2" class="toggle"><li><details open=""><summary>方案2</summary><p id="d7605640-2eec-49e2-a2e9-9d6b0bb3c7db" class="">既然「方案一」会发生同时竞争左边叉子导致死锁的现象，那么我们就在拿叉子前，加个互斥信号量，代码如下：</p><figure id="a2f95d57-9adf-49ce-b049-1351cf3942f3" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lYjk1MDFiYy0xODkzLTQzZjgtYjZiNC0xYTEzZDNiYjYyOGMucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lYjk1MDFiYy0xODkzLTQzZjgtYjZiNC0xYTEzZDNiYjYyOGMucG5n?x-oss-process=image/format,png"/></a></figure><p id="71b3b68a-4506-47a8-8638-6d63964f62cd" class="">上面程序中的互斥信号量的作用就在于，<strong>只要有一个哲学家进入了「临界区」，也就是准备要拿叉子时，其他哲学家都不能动，只有这位哲学家用完叉子了，才能轮到下一个哲学家进餐。</strong></p><figure id="c337e478-4768-401a-9ded-29c8e718c519" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNmY0Y2FhYS0xNzI5LTRkYTAtYTIxYy0zNTVlZWE3YTYyZGQucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hNmY0Y2FhYS0xNzI5LTRkYTAtYTIxYy0zNTVlZWE3YTYyZGQucG5n?x-oss-process=image/format,png"/></a></figure><p id="5998fbe4-c058-4dac-a78d-3453dfd7bce6" class="">方案二的问题</p><p id="57ccc8bd-45d8-4a08-92b1-317581f4326b" class="">方案二虽然能让哲学家们按顺序吃饭，但是每次进餐只能有一位哲学家，而桌面上是有 5 把叉子，按道理是能可以有两个哲学家同时进餐的，所以从效率角度上，这不是最好的解决方案。</p></details></li></ul><ul id="7de22b99-baf0-4c8a-a1a0-63b4cf364e52" class="toggle"><li><details open=""><summary>方案3</summary><p id="b692eca9-7352-4b9d-8467-24e76798f55b" class="">那既然方案二使用互斥信号量，会导致只能允许一个哲学家就餐，那么我们就不用它。</p><p id="299d1731-0422-43d1-b959-290bb0a1e32c" class="">另外，方案一的问题在于，会出现所有哲学家同时拿左边刀叉的可能性，那我们就避免哲学家可以同时拿左边的刀叉，采用分支结构，根据哲学家的编号的不同，而采取不同的动作。</p><p id="483c13a0-48f6-48b5-be4b-aed384e97114" class=""><strong>即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。</strong></p><figure id="01794a37-930b-47e6-8021-5d71611360cc" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84MzJiOGFjNi1lNzJjLTQzYTUtYTkzOC1jY2FkZjc4MGZiMDEucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84MzJiOGFjNi1lNzJjLTQzYTUtYTkzOC1jY2FkZjc4MGZiMDEucG5n?x-oss-process=image/format,png"/></a></figure><p id="05da9210-117b-4b6a-a155-fc0d7ffb7f0f" class="">上面的程序，在 P 操作时，根据哲学家的编号不同，拿起左右两边叉子的顺序不同。另外，V 操作是不需要分支的，因为 V 操作是不会阻塞的。</p><figure id="4d75b8b7-603e-4cdb-bc90-6c4c0c35cb81" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82Y2Y0ZGRkZi00OGIxLTRjMzYtYjQyNC02Mjc2NzA5NzZhNWIucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82Y2Y0ZGRkZi00OGIxLTRjMzYtYjQyNC02Mjc2NzA5NzZhNWIucG5n?x-oss-process=image/format,png"/></a></figure><p id="16c745e0-3f43-4fcc-93ef-33270823df3d" class="">方案三即不会出现死锁，也可以两人同时进餐。</p></details></li></ul><ul id="875d7684-8db6-4938-bd0b-e76619aed629" class="toggle"><li><details open=""><summary>方案4</summary><p id="a087fec6-a14c-43cf-a3d6-68c0517f3a15" class="">在这里再提出另外一种可行的解决方案，我们<strong>用一个数组 state 来记录每一位哲学家在进程、思考还是饥饿状态（正在试图拿叉子）。</strong></p><p id="80af442e-ef82-4da4-8c7e-39febe81ac0d" class="">那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。</strong></p><p id="3352789d-fb87-401c-914f-fca4b554839d" class="">第 <code>i</code> 个哲学家的左邻右舍，则由宏 <code>LEFT</code> 和 <code>RIGHT</code> 定义：<div class="indented"><ul id="3363ed84-cd56-4308-bde6-113189be2976" class="bulleted-list"><li style="list-style-type:disc"><em>LEFT</em> : ( i + 5 - 1 ) % 5</li></ul><ul id="dd344ed4-1f28-410f-a05f-87926fec7c6a" class="bulleted-list"><li style="list-style-type:disc"><em>RIGHT</em> : ( i + 1 ) % 5</li></ul></div></p><p id="9106f331-5be8-40e5-ad7c-529800041b42" class="">比如 i 为 2，则 <code>LEFT</code> 为 1，<code>RIGHT</code> 为 3。</p><p id="43158e02-3b85-4c01-a09a-b389b1a82c6d" class="">具体代码实现如下：</p><figure id="10942534-61aa-477b-afeb-f3d33cc74913" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mNzFhMmQ3YS05NDgyLTRlZWEtOGE5ZS0zMDYyNjNlNzA0MzIucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mNzFhMmQ3YS05NDgyLTRlZWEtOGE5ZS0zMDYyNjNlNzA0MzIucG5n?x-oss-process=image/format,png"/></a></figure><p id="031e7534-9d75-44a9-9dfb-524d4db663e2" class="">上面的程序使用了一个信号量数组，每个信号量对应一位哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞。</p><p id="a07064fb-759a-4623-8908-4a8fa879784e" class="">注意，每个进程/线程将 <code>smart_person</code> 函数作为主代码运行，而其他 <code>take_forks</code>、<code>put_forks</code> 和 <code>test</code> 只是普通的函数，而非单独的进程/线程。</p><figure id="de6e9151-8e1f-4c93-9564-149a53056aed" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iZWNhYzNlOS0zMWY3LTQ5ZTQtYjNiZi03ZjQ0OTMzZjQ1MTUucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iZWNhYzNlOS0zMWY3LTQ5ZTQtYjNiZi03ZjQ0OTMzZjQ1MTUucG5n?x-oss-process=image/format,png"/></a></figure><p id="c4313581-55e4-4721-a4bd-6d21c8819dae" class="">方案四也可解决问题</p><p id="2b5a101d-4a9b-4866-bc19-0e4306083007" class="">方案四同样不会出现死锁，也可以两人同时进餐。</p><ul id="7d9db036-b72b-4bf7-a757-d67380f8ef4c" class="toggle"><li><details open=""><summary></summary></details></li></ul></details></li></ul></details></li></ul><ul id="5c9fb675-2fa0-4c1a-845d-67633aa0095b" class="toggle"><li><details open=""><summary>读者写者 - 信号量实现同步</summary><ul id="a629d469-7b40-43ef-aef1-ff00c3d68756" class="toggle"><li><details open=""><summary>读者-写者的问题描述：</summary><p id="0e06e635-6741-43e4-ba18-257ff80b06a5" class="">它为数据库访问建立了一个模型。（cmu实验讲过）</p><p id="1ea876a9-f225-4e68-a750-a8ee0451d125" class="">读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。</p><ul id="9c143980-5927-473d-bc6e-b75658997b7f" class="bulleted-list"><li style="list-style-type:disc">「读-读」允许：同一时刻，允许多个读者同时读</li></ul><ul id="8945e4e7-4831-41ab-aa9e-cc2e33cb4ff2" class="bulleted-list"><li style="list-style-type:disc">「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写</li></ul><ul id="e6fee321-293e-496e-8df9-312f8a7a52c8" class="bulleted-list"><li style="list-style-type:disc">「写-写」互斥：没有其他写者时，写者才能写</li></ul></details></li></ul><ul id="41440a02-66d4-41b1-b6a4-d382ee59fd91" class="toggle"><li><details open=""><summary>方案1</summary><p id="2743b4a4-0b5f-4b93-8ae7-29d718a0148b" class="">使用信号量的方式来尝试解决：<div class="indented"><ul id="444850c1-a2d3-4563-86d2-fbf30470a629" class="bulleted-list"><li style="list-style-type:disc">信号量 <code>wMutex</code>：控制写操作的互斥信号量，初始值为 1 ；</li></ul><ul id="2b355280-5f25-440b-abca-879dc5c03d76" class="bulleted-list"><li style="list-style-type:disc">读者计数 <code>rCount</code>：正在进行读操作的读者个数，初始化为 0；</li></ul><ul id="9722b3c5-9962-4f51-b797-516b4ab2b37a" class="bulleted-list"><li style="list-style-type:disc">信号量 <code>rCountMutex</code>：控制对 rCount 读者计数器的互斥修改，初始值为 1；</li></ul></div></p><p id="f68bff25-4fc2-4a79-a455-d06db5286f44" class="">接下来看看代码的实现：</p><figure id="81418f20-c700-41a2-86cb-a686e179854c" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kN2M0YzVkYy0wODEyLTRlNmEtYTdhYS0yY2RiZGU5ZjkwMTkucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kN2M0YzVkYy0wODEyLTRlNmEtYTdhYS0yY2RiZGU5ZjkwMTkucG5n?x-oss-process=image/format,png"/></a></figure><p id="fa9b1475-fa89-4d8e-8184-3a0ddf1d2472" class="">上面的这种实现，是读者优先的策略，因为只要有读者正在读的状态，后来的读者都可以直接进入，如果读者持续不断进入，则写者会处于饥饿状态。</p></details></li></ul><ul id="096f5b85-e9e6-4de4-88a9-c608ae4dcbd4" class="toggle"><li><details open=""><summary>方案2</summary><p id="9be8a881-3e9a-46c6-bfab-acb14d7689f9" class="">那既然有读者优先策略，自然也有写者优先策略：</p><ul id="9c3fdd08-a289-409e-b3f1-def24a633fe6" class="bulleted-list"><li style="list-style-type:disc">只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；</li></ul><ul id="799e0770-2e45-457f-9252-dde1ad1de813" class="bulleted-list"><li style="list-style-type:disc">如果有写者持续不断写入，则读者就处于饥饿；</li></ul><p id="749ebff3-121b-4807-9a1a-b6df2c494855" class="">在方案一的基础上新增如下变量：</p><ul id="8044147a-b379-47ba-b527-512b0b525ba3" class="bulleted-list"><li style="list-style-type:disc">信号量 <code>rMutex</code>：控制读者进入的互斥信号量，初始值为 1；</li></ul><ul id="aff17247-fe47-4cd9-8289-5e91c8cd06b1" class="bulleted-list"><li style="list-style-type:disc">信号量 <code>wDataMutex</code>：控制写者写操作的互斥信号量，初始值为 1；</li></ul><ul id="301b3b91-3282-4196-b638-71bbd395f2c3" class="bulleted-list"><li style="list-style-type:disc">写者计数 <code>wCount</code>：记录写者数量，初始值为 0；</li></ul><ul id="128b5843-e8b3-4b75-bf8e-465db46123a8" class="bulleted-list"><li style="list-style-type:disc">信号量 <code>wCountMutex</code>：控制 wCount 互斥修改，初始值为 1；</li></ul><p id="068988da-2e47-4f59-a6b7-44e07dba0613" class="">具体实现如下代码：</p><figure id="cf9dfd31-5366-402b-8ead-a1941bbbc521" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83NTc4MjIyYy1kODA1LTQ5NDctYTQwZS1lODI2N2E1ZWZlZjkucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83NTc4MjIyYy1kODA1LTQ5NDctYTQwZS1lODI2N2E1ZWZlZjkucG5n?x-oss-process=image/format,png"/></a></figure><p id="fa9e825e-2013-4381-b7c5-5442c76bd90d" class="">注意，这里 <code>rMutex</code> 的作用，开始有多个读者读数据，它们全部进入读者队列，此时来了一个写者，执行了 <code>P(rMutex)</code> 之后，后续的读者由于阻塞在 <code>rMutex</code> 上，都不能再进入读者队列，而写者到来，则可以全部进入写者队列，因此保证了写者优先。</p><p id="8bc47da6-b916-4b68-82ed-fab47e6875d9" class="">同时，第一个写者执行了 <code>P(rMutex)</code> 之后，也不能马上开始写，必须等到所有进入读者队列的读者都执行完读操作，通过 <code>V(wDataMutex)</code> 唤醒写者的写操作。</p></details></li></ul><ul id="1376027a-61a1-45cc-9a78-86711ef15a81" class="toggle"><li><details open=""><summary>方案3</summary><p id="8b1836ba-2260-4808-9298-5970893cbdbb" class="">既然读者优先策略和写者优先策略都会造成饥饿的现象，那么我们就来实现一下公平策略。</p><p id="0c19c9a3-dae6-4ef9-9d06-61ac07bc50d1" class="">公平策略：</p><ul id="695b669c-5b4e-4342-9126-1cb45878eabe" class="bulleted-list"><li style="list-style-type:disc">优先级相同；</li></ul><ul id="2de6a193-5d71-40b6-8932-47d211267062" class="bulleted-list"><li style="list-style-type:disc">写者、读者互斥访问；</li></ul><ul id="37844595-ddbf-4e83-8847-24f843cc40c4" class="bulleted-list"><li style="list-style-type:disc">只能一个写者访问临界区；</li></ul><ul id="d349b307-f31a-45e0-85e5-ae0696a05df8" class="bulleted-list"><li style="list-style-type:disc">可以有多个读者同时访问临街资源；</li></ul><p id="43c73e2f-abe8-4a4c-9352-6709f236acc9" class="">具体代码实现：</p><figure id="9f84f888-d243-48fd-b1ae-a1ca79157ea7" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84MDI4ZWQwYi1jMWYyLTRlNTItYThlZi1lZDQzM2FhM2M0YTcucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84MDI4ZWQwYi1jMWYyLTRlNTItYThlZi1lZDQzM2FhM2M0YTcucG5n?x-oss-process=image/format,png"/></a></figure><p id="488e865e-c1f8-4f63-98bb-51bafaf6d5b3" class="">看完代码不知你是否有这样的疑问，为什么加了一个信号量 <code>flag</code>，就实现了公平竞争？</p><p id="9ae9c0d0-2010-4f7f-b8f4-2de057182404" class="">对比方案一的读者优先策略，可以发现，读者优先中只要后续有读者到达，读者就可以进入读者队列， 而写者必须等待，直到没有读者到达。</p><p id="ef5be072-4bfc-43fc-b50e-be6765e50ad9" class="">没有读者到达会导致读者队列为空，即 <code>rCount==0</code>，此时写者才可以进入临界区执行写操作。</p><p id="31c7d453-2744-4016-b358-03f4ffee59b9" class="">而这里 <code>flag</code> 的作用就是阻止读者的这种特殊权限（特殊权限是只要读者到达，就可以进入读者队列）。</p><p id="900a5d46-5058-4b16-b56a-adeddfd38cbf" class="">比如：开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 <code>P(falg)</code> 操作，使得后续到来的读者都阻塞在 <code>flag</code> 上，不能进入读者队列，这会使得读者队列逐渐为空，即 <code>rCount</code> 减为 0。</p><p id="26c20819-6bc5-4835-bb02-dbe459bcf931" class="">这个写者也不能立马开始写（因为此时读者队列不为空），会阻塞在信号量 <code>wDataMutex</code> 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 <code>V(wDataMutex)</code>，唤醒刚才的写者，写者则继续开始进行写操作。</p></details></li></ul></details></li></ul><ul id="4282feb9-6d1a-4336-9922-d12cb41158d8" class="toggle"><li><details open=""><summary><a href="https://blog.csdn.net/qq_33414271/article/details/80245715">银行家算法</a> - 避免死锁</summary><p id="318fd3a3-c324-4dc3-b3d6-a0149e234871" class="">一句话：当一个进程申请使用资源的时候，银行家算法通过先<mark class="highlight-red"><strong> 试探 </strong></mark>分配给该进程资源，然后通过<strong>安全性算法</strong>判断分配后的系统<strong>是否处于安全状态</strong>，若不安全则试探分配作废，让该进程继续等待。</p><ul id="8fd7b5a6-9d1c-4131-838e-63431984e358" class="toggle"><li><details open=""><summary>图解</summary><figure id="69823006-66bd-4404-950c-a434be218047" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2022.png"><img style="width:816px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2022.png"/></a></figure><ul id="3f081ed9-6367-4491-992d-e1d11ae93007" class="toggle"><li><details open=""><summary>首先是银行家算法中的进程：</summary><p id="28020d8b-6fc3-4b2b-9ce7-caf0655fa6c2" class="">包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）
已分配给该进程的资源A（Allocation）
还需要的资源数量N（Need=M-A）</p><p id="dfb24aa9-2ba9-4b56-83f8-de3b5134d218" class="">Available为空闲资源数量，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）</p></details></li></ul><p id="5a556af6-11d5-4b3f-a143-645fdc147d61" class="">假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕</p><p id="22bbb4a1-4c83-4023-9b6a-fa1a51c54843" class="">若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。</p><p id="0c0d3ecf-cd0c-4117-a675-013553d21fe4" class="">若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–&gt;回收（Work+已分配给P0的A0=Work）–&gt;分配给P3–&gt;回收（Work+A3=Work）–&gt;分配给P2–&gt;······满足所有进程）。</p><p id="6507e62d-ff48-4881-9af0-1ae987ced52f" class="">如此就可避免系统存在潜在死锁的风险。</p></details></li></ul></details></li></ul><p id="25165a61-5a4a-4a8e-b674-9f213ec77462" class="">
</p><p id="ea6b67a0-9b3a-43f5-9965-386eab7c0ad0" class="">面试：思考算法的改进</p></details></li></ul></details></li></ul><ul id="9eead981-1211-4f0a-8a35-0096f890ee96" class="toggle"><li><details open=""><summary><strong>同步</strong></summary><ul id="003d1e66-8830-4531-a08c-91c286f7a4c1" class="toggle"><li><details open=""><summary><em>信号量</em>：P、V 操作；</summary><ul id="ef39b5c3-d22a-4537-bf68-1f16d1da9de9" class="toggle"><li><details open=""><summary>why意义 <mark class="highlight-red">-为共享内存服务</mark></summary><p id="81aa3134-7ada-44ca-8c09-6f0282d740cd" class="">信号量为控制一个具有有限数量用户资源而设计。解决共享内存的问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。</p></details></li></ul><ul id="1f2994ab-ab57-414c-ad79-ebfa4ea076a2" class="toggle"><li><details open=""><summary>什么是信号量：</summary><p id="05781e8d-2534-42ef-b5bd-948f266c728a" class="">它<mark class="highlight-red">允许同一时刻多个线程访问同一资源</mark>，但是需要控制同一时刻访问此资源的最大线程数量。</p><ul id="52ef2c1f-59c9-454a-8375-b44acc60860f" class="toggle"><li><details open=""><summary>是操作系统提供的一种协调共享资源访问的方法。<mark class="highlight-red">通常信号量表示资源的数量</mark>，对应的变量是一个整型（<mark class="highlight-red"><strong>sem</strong></mark>）变量。控制信号量的方式有两种<mark class="highlight-red">原子操作</mark>：（pv荷兰语缩写）</summary><p id="6ac034bb-72dc-4c3a-b1f2-e27bd6c9ac29" class="">P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><ul id="a0c378f5-d97c-4153-8ef0-38e5f4328bdd" class="toggle"><li><details open=""><summary><em>P 操作</em>：将 <code>sem</code> 减 <code>1</code>，相减后，如果 <code>sem &amp;lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</summary><p id="a2be88e0-dfaf-4276-8246-e7d8febba8b6" class="">相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；
相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</p></details></li></ul><ul id="480418ec-46d0-423f-bc14-1f05ff942bf7" class="toggle"><li><details open=""><summary><em>V 操作</em>：将 <code>sem</code> 加 <code>1</code>，相加后，如果 <code>sem &amp;lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</summary><p id="a8df93e5-e740-4c27-a3a9-5d9aab92291a" class="">相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；
相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</p></details></li></ul><figure id="4985c9cd-18f3-4b9e-85ae-35e87efc0b9a" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2023.png"><img style="width:432px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2023.png"/></a></figure></details></li></ul><p id="387688ab-b663-472a-b2b3-21a0c4526f6d" class="">
</p><p id="122eebe5-e5f5-46a8-8340-39bd1decb1ff" class="">（semaphore[ˈseməfɔ:(r)]）<mark class="highlight-red">信号量其实是一个整型的计数器</mark>，主要用于<mark class="highlight-red"><strong>实现进/线程间的互斥与同步</strong></mark>，<span style="border-bottom:0.05em solid">而</span><span style="border-bottom:0.05em solid"><strong>不是用于缓存</strong></span><span style="border-bottom:0.05em solid">进程间通信的数据</span>。</p></details></li></ul><ul id="a51d71da-df88-472e-8a40-a96c33317ec4" class="toggle"><li><details open=""><summary>例子</summary><ul id="baf574a9-69ec-4237-a2c1-d24b3afccdbe" class="toggle"><li><details open=""><summary>举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。具体的过程如下：</summary><ul id="b94b851a-9efc-440e-b478-37350cd09811" class="bulleted-list"><li style="list-style-type:disc">进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li></ul><ul id="8591b4ec-7f47-444f-a2c1-c4762371c45e" class="bulleted-list"><li style="list-style-type:disc">若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li></ul><ul id="039a288c-57db-4a66-bdf6-3917725e3caf" class="bulleted-list"><li style="list-style-type:disc">直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul></details></li></ul><p id="855fee2e-a902-45d2-9152-d5a8ef260017" class="">可以发现，<mark class="highlight-red">信号初始化为 </mark><mark class="highlight-red"><code>1</code></mark><mark class="highlight-red">，就代表着是</mark><mark class="highlight-red"><strong>互斥信号量</strong></mark>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p id="d86324b7-ba6b-4ae8-8846-730bdf3f541f" class="">另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><figure id="456eaac1-928e-41fd-b6c5-57cc37955ee7" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YmI2YmUwMS0wY2JhLTRhMzUtYTkzMS1iZmE5ODFlNGViZDkucG5n?x-oss-process=image/format,png"><img style="width:288px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YmI2YmUwMS0wY2JhLTRhMzUtYTkzMS1iZmE5ODFlNGViZDkucG5n?x-oss-process=image/format,png"/></a></figure><ul id="7b6ec0dd-9d9c-4d28-83b1-2e3972e9576b" class="toggle"><li><details open=""><summary>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。具体过程：</summary><ul id="8d88b32d-9e60-4c07-8607-08e40f58f228" class="bulleted-list"><li style="list-style-type:disc">如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li></ul><ul id="6f69f38a-c5f1-4bb5-9772-ede6cfe9ebb0" class="bulleted-list"><li style="list-style-type:disc">接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li></ul><ul id="f7ae9947-8e6b-4dd7-9c14-a8e4b89fa198" class="bulleted-list"><li style="list-style-type:disc">最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul></details></li></ul><p id="09c46b9e-4191-4412-b1f0-8777572f6be7" class="">可以发现，<mark class="highlight-red">信号初始化为 </mark><mark class="highlight-red"><code>0</code></mark><mark class="highlight-red">，就代表着是</mark><mark class="highlight-red"><strong>同步信号量</strong></mark>，它可以保证进程 A 应在进程 B 之前执行。</p></details></li></ul><ul id="8a95e4ca-1f17-43df-b53b-7e9289698d54" class="toggle"><li><details open=""><summary>linux code 实现 PV 操作</summary><p id="2c561128-df49-426d-9c00-2edf058fb803" class="">PV 操作的函数是由操作系统管理和实现的，所以操作系统已经使得执行 PV 函数时是具有原子性的。</p><figure id="1c6e6d7d-3e07-4d63-96eb-dcb7ad668f56" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2024.png"><img style="width:2612px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2024.png"/></a></figure></details></li></ul><ul id="abd33c9b-e263-4bc3-9249-72fd76a65b27" class="toggle"><li><details open=""><summary>PV 操作 应用？</summary><p id="45f0dba4-6a9e-460d-8f1a-53c1df73fd1a" class="">信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</p><ul id="cc4e41a1-be75-4bd1-99d5-ffc94d6f006c" class="toggle"><li><details open=""><summary>临界区的互斥访问</summary><p id="1bb74bb4-a3a4-4ec8-a032-5e18d7b5ba1d" class="">为每类共享资源设置一个信号量 <code>s</code>，其初值为 <code>1</code>，表示该临界资源未被占用。</p><p id="4512d108-25d1-4010-93f5-a1e79b34e4df" class="">只要把进入临界区的操作置于 <code>P(s)</code> 和 <code>V(s)</code> 之间，即可实现进程/线程互斥：</p><figure id="cb08bc9f-583d-46dd-b6b6-5b2c7fb1350c" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2025.png"><img style="width:336px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2025.png"/></a></figure><p id="b96d13d2-f8d9-457d-ad80-c3b2d59a3a6d" class="">此时，任何想进入临界区的线程，必先在互斥信号量上执行 P 操作，在完成对临界资源的访问后再执行 V 操作。由于互斥信号量的初始值为 1，故在第一个线程执行 P 操作后 s 值变为 0，表示临界资源为空闲，可分配给该线程，使之进入临界区。</p><p id="72bec658-307c-44f6-8ebc-de008a97d01f" class="">若此时又有第二个线程想进入临界区，也应先执行 P 操作，结果使 s 变为负值，这就意味着临界资源已被占用，因此，第二个线程被阻塞。</p><p id="d58582b4-64c8-4b95-a428-aac88574bbc9" class="">并且，直到第一个线程执行 V 操作，释放临界资源而恢复 s 值为 0 后，才唤醒第二个线程，使之进入临界区，待它完成临界资源的访问后，又执行 V 操作，使 s 恢复到初始值 1。</p><p id="26583287-2656-42c9-a7e8-3cc4fac5b74b" class="">对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：</p><ul id="b13348b1-3bc3-4df4-a732-5eebb8f8713c" class="bulleted-list"><li style="list-style-type:disc">如果互斥信号量为 1，表示没有线程进入临界区；</li></ul><ul id="4a1fcb87-eb9d-418f-b0a0-c6c38a847168" class="bulleted-list"><li style="list-style-type:disc">如果互斥信号量为 0，表示有一个线程进入临界区；</li></ul><ul id="8b5b040f-9212-4f58-865a-f27e311a06d6" class="bulleted-list"><li style="list-style-type:disc">如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。</li></ul><p id="978ed467-b1e7-4b10-9787-f3e69e97b632" class="">通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。</p></details></li></ul><ul id="b0f3c411-894e-47a1-8184-7321f273cc40" class="toggle"><li><details open=""><summary><strong>实现事件同步</strong></summary><p id="5e071e32-61f7-4b09-80bf-251f15caf945" class="">同步的方式是设置一个信号量，其初值为 <code>0</code>。</p><p id="49a9b2da-42c9-449f-944a-c40e35624f40" class="">我们把前面的「吃饭-做饭」同步的例子，用代码的方式实现一下：</p><figure id="6866c645-67ba-4d59-b220-75630eb99ecb" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80MmVmNjQ2NS1iN2ZkLTRmZmMtOTIyOS0zZmIwMzAzYjlhY2YucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80MmVmNjQ2NS1iN2ZkLTRmZmMtOTIyOS0zZmIwMzAzYjlhY2YucG5n?x-oss-process=image/format,png"/></a></figure><p id="1df65f1e-744d-468e-b493-3b2f5e681133" class="">妈妈一开始询问儿子要不要做饭时，执行的是 <code>P(s1)</code> ，相当于询问儿子需不需要吃饭，由于 <code>s1</code> 初始值为 0，此时 <code>s1</code> 变成 -1，表明儿子不需要吃饭，所以妈妈线程就进入等待状态。</p><p id="ef0ac8ff-418e-46d6-83b1-2d61d984c307" class="">当儿子肚子饿时，执行了 <code>V(s1)</code>，使得 <code>s1</code> 信号量从 -1 变成 0，表明此时儿子需要吃饭了，于是就唤醒了阻塞中的妈妈线程，妈妈线程就开始做饭。</p><p id="8e0acd5f-5258-422e-bf1a-b051c5ab01cd" class="">接着，儿子线程执行了 <code>P(s2)</code>，相当于询问妈妈饭做完了吗，由于 <code>s2</code> 初始值是 0，则此时 <code>s2</code> 变成 -1，说明妈妈还没做完饭，儿子线程就等待状态。</p><p id="1e59cbc6-516c-4ecb-9d2a-8545ff29d8fd" class="">最后，妈妈终于做完饭了，于是执行 <code>V(s2)</code>，<code>s2</code> 信号量从 -1 变回了 0，于是就唤醒等待中的儿子线程，唤醒后，儿子线程就可以进行吃饭了。</p></details></li></ul></details></li></ul><ul id="a4c4004d-551a-4d00-924f-3b38e8ebe2f0" class="toggle"><li><details open=""><summary><a href="https://www.cnblogs.com/xiaolincoding/p/13346658.html">经典同步问题</a></summary><p id="1e48ef07-f88b-442b-be81-2d29ca3a8c01" class="">跳到死锁</p></details></li></ul><ul id="62642a99-0271-4970-beed-f2e5abb29f8a" class="toggle"><li><details open=""><summary>包括无名线程信号量和命名线程信号量</summary></details></li></ul></details></li></ul><ul id="c57d8d55-ef20-4c57-a747-673cfac26d1d" class="toggle"><li><details open=""><summary><strong>事件（event） </strong></summary><ul id="4509492f-b5fe-4864-8b44-255f88dcd2b7" class="toggle"><li><details open=""><summary>1.什么是事件？</summary><ul id="21e4fa87-1d0a-4152-be41-1a7b97bce247" class="toggle"><li><details open=""><summary>又叫线程触发器，不可以跨进程，要么存在要么没有，一个线程来唤醒另一个线程（包括自动和人工两种方式）</summary></details></li></ul><p id="5313e675-8f8d-49bb-a269-bcd62fe916b9" class="">事件Event对象是内核对象，代表系统的某一个状态（如），每一个事件都对应了一个事件触发函数。</p><p id="c7a517ae-415a-43a4-b960-ebaeb02a265c" class="">4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><ul id="6b5cd98e-0842-4dfb-8e10-57fca29c2e16" class="toggle"><li><details open=""><summary>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</summary></details></li></ul></details></li></ul><ul id="0b908a7a-a306-4588-9ad2-5a0ec7aae3f7" class="toggle"><li><details open=""><summary>2.事件什么时候产生?</summary><p id="fc5a61b6-855a-4d84-a4ec-5e186b17a328" class="">当用户触发某元素的特定事件的时候（如：mouseMove,click），事件会调用事件响应函数，传递下去，函数不会在事件发生前被执行。</p></details></li></ul></details></li></ul><p id="23e78d79-16c6-4513-8205-70d8adeb53c0" class="">
</p></details></li></ul><ul id="709ad9d3-e00b-4add-946e-8824160f4277" class="toggle"><li><details open=""><summary><mark class="highlight-red">通信方法</mark></summary><p id="fe5b0a51-5542-4805-aac4-acecabf5df95" class="">IPC（Inter Process Communication）</p><ul id="9620342f-52ca-4f70-b81b-25283f46454b" class="toggle"><li><details open=""><summary>why <a href="https://blog.csdn.net/alpha_love/article/details/62238170">进程间需要通信</a>？</summary><p id="9a50b566-1bc7-4414-99b5-863cce192eba" class="">通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p><p id="4e69ed35-f31b-4b89-bd23-e6909721b8ec" class="">进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p><p id="2d1e80c8-47c4-46b8-905d-40b80b21224e" class="">数据传输：一个进程需要将它的数据发送给另一个进程。（copy粘贴，大量并行计算）</p><p id="89e6ffcc-cba6-47d7-a115-38438e186e1d" class="">
</p></details></li></ul><ul id="6f27ffb7-0203-4c51-8506-8bde7487860a" class="toggle"><li><details open=""><summary>what 进程间通信 - 定义</summary><p id="ecf33ad8-3c6d-4b04-8081-a072ea4d183b" class=""><strong>进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。</strong></p></details></li></ul><ul id="7c374fda-3ff7-4fff-930b-666d3bebc5ce" class="toggle"><li><details open=""><summary>what 线程间通信 - 定义</summary><p id="78da6f57-722c-40c1-bf86-32c37cbb86ad" class=""><mark class="highlight-red"><a href="https://zhuanlan.zhihu.com/p/365838214">线程通信是同一个进程的多个子线程之间的通信。</a></mark></p><p id="0df2331d-5586-432c-b28a-10e22b7e7081" class="">（一个进程下的线程间是共享内存空间的，故线程A可以之间访问线程B中定义的变量，但是必须注意并发的情况）</p><p id="2d3f2cf1-a68f-4079-bab4-1e09fb04a70a" class=""><mark class="highlight-red">理论上所有的进程通信方式都是可以达到线程间通信的</mark>，因为进程就可以看作是一个不能为空的线程集。下面我们主要谈一些线程层面的或者说特有的通信方式。</p><figure id="e727e5f4-524d-4d30-bbc1-2edcabce07e4" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2026.png"><img style="width:518px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2026.png"/></a><figcaption>单个进程下多线程地址空间分布图</figcaption></figure></details></li></ul><ul id="eb61ab7c-4a95-4a80-ab81-f588053a29f2" class="toggle"><li><details open=""><summary>where 在哪里通信？</summary><p id="ce1184c8-08fa-440c-bf6c-9ed74aac59e5" class="">每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<mark class="highlight-red">进程之间要通信必须通过内核</mark>。（想一想linux 用户分区）</p><figure id="52dd0ad1-7195-4937-ba37-1b0a2ad0c3a8" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8wMzFkNTE2ZDFjYzY0ZWIyYWM5MWY5Nzg3NWJmOTQzMy5wbmc?x-oss-process=image/format,png"><img style="width:480px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8wMzFkNTE2ZDFjYzY0ZWIyYWM5MWY5Nzg3NWJmOTQzMy5wbmc?x-oss-process=image/format,png"/></a></figure></details></li></ul><p id="424e5a66-0d5f-4aae-963b-d5af07bdb7a4" class="block-color-orange_background"><strong>方法：</strong><mark class="highlight-red"><strong>（定义&amp;优缺点</strong></mark>）</p><ul id="8ef24532-692f-4aa7-b5f7-30e1927fa472" class="toggle"><li><details open=""><summary><mark class="highlight-red">管道</mark></summary><ul id="62f282e5-78fe-4d3d-9cfe-3aa271f18a03" class="toggle"><li><details open=""><summary>定义: 管道，就是内核里面的一串缓存</summary><p id="b1b4f471-6e2b-4b6e-b76d-fc01666b4bed" class="">从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。</p><p id="7e07054c-ceea-412a-8a73-2f2667f53376" class="">系统调用：<code>pipe创建管道</code></p></details></li></ul><ul id="6c0951a8-2b51-43e8-ba0a-603e1056dbd0" class="toggle"><li><details open=""><summary>特征：</summary><ul id="9e9eda35-0cff-44d9-8d5e-b24b3083eebc" class="toggle"><li><details open=""><summary>单向, 先进先出</summary></details></li></ul><p id="fef08b28-3fde-4aa0-afeb-252ca31cdc82" class="">golang 中的 channel</p><figure id="a418813d-52ef-4c47-becf-417cf77bf18f" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2027.png"><img style="width:672px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2027.png"/></a></figure></details></li></ul><ul id="5d55d819-a305-4b7f-baf1-6ed95d28e436" class="toggle"><li><details open=""><summary>优缺点</summary><ul id="d5754315-5587-4c3a-9700-721b7e0025da" class="toggle"><li><details open=""><summary>缺点：管道这种通信方式效率低，不适合进程间频繁地交换数据</summary></details></li></ul><ul id="2f5ae5f0-aba1-4542-8415-30b3dea0c299" class="toggle"><li><details open=""><summary>好处：自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了</summary></details></li></ul></details></li></ul><ul id="43ad78ff-b034-4ccb-8695-c937c2602e12" class="toggle"><li><details open=""><summary>分类</summary><ul id="cf04456c-ffe0-44a0-aabf-737f5394f9fd" class="toggle"><li><details open=""><summary>1 匿名管道: 用完了就销毁, 通信范围是存在父子关系的进程</summary><p id="05fa1ea7-d190-444c-b04c-9fa07ed535fc" class="">如果你学过 Linux 命令，那你肯定很熟悉「<code>|</code>」这个竖线。</p><pre id="9bb6c077-7843-4ecb-9a38-d54abd1d3207" class="code code-wrap"><code>$ ps auxf | grep mysql</code></pre><p id="f23dddd7-cfcd-4016-8e7b-b2a13cd1bfee" class="">上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是将前一个命令（<code>ps auxf</code>）的输出，作为后一个命令（<code>grep mysql</code>）的输入，从这功能描述，可以看出<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p></details></li></ul><ul id="554635c7-2538-4f6c-b7ab-6cf23db2c295" class="toggle"><li><details open=""><summary>2 命名管道: 它可以在不相关的进程间也能相互通信</summary><ul id="22308fc6-6150-4c42-95a5-0c97c70e2748" class="toggle"><li><details open=""><summary>命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</summary></details></li></ul></details></li></ul></details></li></ul></details></li></ul><ul id="2c2f3f0b-1d11-411e-861d-8ba8b7268fff" class="toggle"><li><details open=""><summary><mark class="highlight-red">消息队列</mark></summary><p id="8a09c864-c355-497c-8aae-997dcb035510" class="">（eg：半连接队列，全连接队列）</p><ul id="0bcbc686-1498-48f2-be87-4822332c612f" class="toggle"><li><details open=""><summary>定义/形态：消息队列是<mark class="highlight-red">保存在内核中</mark>的消息链表 </summary><p id="e3b015f1-4a5c-4364-b98e-f4a0738d8058" class="">在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以<mark class="highlight-red">每个消息体都是固定大小的存储块</mark>，不像<mark class="highlight-red">管道是无格式的字节流数据</mark>。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p id="d3095441-3e37-4abf-b792-4aaa2af2cb80" class="">图a)</p><figure id="81f30f9d-8ea9-491a-be11-a18d8d963982" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2028.png"><img style="width:528px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2028.png"/></a></figure></details></li></ul><ul id="0dbf5254-fd6d-4c7f-aa50-77c7a477964d" class="toggle"><li><details open=""><summary>优缺点</summary><p id="2f15fdb9-926f-4cb3-9cca-d82638da9946" class="">优点<div class="indented"><p id="779d43d8-0563-44ca-b6c3-18b466f2c43c" class="">效率比管道高，可实现频繁通信</p><p id="e065405e-e32d-4bdb-8e95-deea2e45c3b7" class="">e.g.  A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p></div></p><p id="ccea3363-cf09-4913-b02d-5ebefa627630" class="">缺点<div class="indented"><ul id="07955eff-99a8-453d-86f2-79487026cca1" class="toggle"><li><details open=""><summary>消息队列不适合比较大数据的传输</summary><p id="a31cef3a-31e6-4648-96a6-c51ebb6bf04c" class=""><mark class="highlight-red">因为在内核中每个消息体都有一个最大长度的限制</mark>，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p></details></li></ul><ul id="15a28242-d8ac-4154-b205-43ed9addcd7f" class="toggle"><li><details open=""><summary>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</summary><p id="dfa0b5d7-fcb3-4c6c-bac2-068ed2b2f922" class="">因为进程写入数据到内核中的消息队列时，会发生从<mark class="highlight-red">用户态拷贝数据到内核态</mark>的过程，同理另一进程读取内核中的消息数据时，会发生从<mark class="highlight-red">内核态拷贝数据到用户态</mark>的过程。</p></details></li></ul></div></p></details></li></ul><ul id="923a28a6-c965-4d1a-93b1-359455307040" class="toggle"><li><details open=""><summary><a href="https://www.yiibai.com/ipc/message_queues.html">系统调用</a></summary><p id="b4b05977-2a35-4ca1-8d17-377cfed800f0" class="">要使用消息队列执行通信，请执行以下步骤 -</p><p id="6ae5ce2c-fe47-4be3-a689-928a292aa8fb" class=""><strong>第1步</strong> - 创建一个消息队列或连接到一个已经存在的消息队列(<code>msgget()</code>)</p><p id="a8f36b59-463b-4f8b-8302-7f6581a1b446" class=""><strong>第2步</strong> - 写入消息队列(<code>msgsnd()</code>)</p><p id="ed11278d-b3a0-4a1b-b073-2f5a37a34909" class=""><strong>第3步</strong> - 从消息队列中读取(<code>msgrcv()</code>)</p><p id="78401e37-c12a-4692-b59e-ef9de5a4fa85" class=""><strong>第4步</strong> - 对消息队列(<code>msgctl()</code>)执行控制操作</p><p id="df8228bb-3063-4c73-99c5-ca827e17d10b" class="">
</p></details></li></ul><ul id="befdd061-9683-4d73-a607-ba5ca4e60923" class="toggle"><li><details open=""><summary>消息队列里面生产者如果消费过了的话会不会直接丢掉？</summary></details></li></ul></details></li></ul><ul id="7ae42054-9560-490e-8f35-a7b17edc54cc" class="toggle"><li><details open=""><summary><mark class="highlight-red">共享内存 - </mark><strong>最快</strong></summary><ul id="f46ea790-835e-423c-b397-8d314bbcdcbc" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">pre知识点</a></summary><ul id="6f696e29-bde7-4bfd-a4ca-2b83200be710" class="toggle"><li><details open=""><summary>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</summary></details></li></ul></details></li></ul><ul id="acb91d84-4a3e-4bbe-8776-b18192ea05ae" class="toggle"><li><details open=""><summary>定义 - 原理</summary><ul id="c6c5711e-6bb5-4375-8d00-8668c2626819" class="toggle"><li><details open=""><summary>共享内存的机制，<strong>就是拿出一块虚拟地址空间来，映射到相同的物理内存中。</strong></summary></details></li></ul><figure id="3aee230a-5619-4f83-9782-6741fcb2b5cc" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2029.png"><img style="width:384px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2029.png"/></a></figure><figure id="940867bb-7bc9-4dcd-840b-76a78ee9df29" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2030.png"><img style="width:672px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2030.png"/></a></figure></details></li></ul><ul id="015362e2-36b8-45fd-b3cd-3a82ae15bc23" class="toggle"><li><details open=""><summary><a href="https://zhuanlan.zhihu.com/p/37808566">系统调用</a> <mark class="highlight-red">共享内存实现的两种方式 - linux</mark></summary><div><ul id="2581b014-c935-4f19-8bf3-51291e0bc2bc" class="toggle"><li><details open=""><summary>1 <a href="https://blog.csdn.net/JMW1407/article/details/107703142">mmap</a> </summary><ul id="f9c61fce-c531-4e23-a289-36f77b39d133" class="toggle"><li><details open=""><summary>综述mmap 原理</summary><p id="b56f6c8a-55b7-43bf-89ab-cc50da012257" class="">mmap是一种内存映射文件的方法，即<mark class="highlight-red">将一个文件或者其它对象映射到进程的地址空间</mark>，实现<mark class="highlight-red">文件磁盘地址</mark>和<mark class="highlight-red">进程虚拟地址</mark>空间中一段虚拟地址的一 一对映关系。</p><ul id="ee76d415-625c-4924-b0dd-3155a9daa304" class="toggle"><li><details open=""><summary>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而<mark class="highlight-red">不必再调用read,write等系统调用函数</mark>。<mark class="highlight-red">具体过程如下</mark>：</summary><p id="0d3f22b8-5cbb-4f18-b022-57f283c41e9f" class="">当存在客户－服务程序中复制文件时候，其数据流如下，要经历四次数据复制，开销很大。具体如下：进程调用read或是write后会陷入内核，因为这两个函数都是系统调用，进入系统调用后，内核开始读写文件</p><p id="47558c0f-5dc5-450c-bfc5-12c203fd53dc" class="">假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。 实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。</p><figure id="6949f95b-08bc-4ce7-88b5-47402f02c27e" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2031.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2031.png"/></a></figure><p id="3d7968ff-bf9f-43aa-8d5e-a8f665c9358b" class="">如果采用共享内存的方式，那么将大大优化IO操作，数据流变成了如下，数据只复制两次，[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。</p><p id="ea2c051b-32ca-421b-b9a3-b893f380cfab" class="">Linux提供了内存映射函数<mark class="highlight-red">mmap</mark>, 它<mark class="highlight-red">把文件内容映射到一段内存上(准确说是虚拟内存上), </mark>通过对这段内存的读取和修改,实现对文件的读取和修改；  普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用(read,write)去操作。</p><figure id="eb1ebd39-d02e-4312-bd7a-820b414d700b" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2032.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2032.png"/></a></figure></details></li></ul><p id="33038df9-53e3-412a-a290-2fed021ffb48" class="">由图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为<mark class="highlight-red">内存映射服务的地址空间处在堆栈之间的空余部分</mark>。</p><figure id="922dd45c-c865-4a4b-8e3e-5219e6f3fc7c" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2033.png"><img style="width:624px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2033.png"/></a></figure></details></li></ul><ul id="cb0b0457-31f9-4817-b308-eedb7364751e" class="toggle"><li><details open=""><summary>mmap 具体调用过程</summary><ul id="6ac43310-ae51-476e-b065-724ff00849c1" class="toggle"><li><details open=""><summary>pre知识点</summary><p id="535e78d7-0ce1-4c70-a6de-a5a6600e88f4" class="">linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问。</p><p id="47a934a4-90c5-420e-a968-8fe0450ca69e" class="">mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。</p><figure id="12782585-33c5-4f58-b72d-a9ddf0f54795" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2034.png"><img style="width:658px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2034.png"/></a></figure></details></li></ul><p id="d09f31c5-7f41-4389-8e86-fdf14a5f4a75" class="">mmap内存映射的实现过程，总的来说可以分为三个阶段：</p><ul id="0df7fda6-8027-4478-97e2-a4c20f5e450b" class="toggle"><li><details open=""><summary>（一）进程启<mark class="highlight-red">动映射过程</mark>，并在虚拟地址空间中为映射创建虚拟映射区域</summary><p id="e6036290-00f7-4a34-bf17-068477d16bce" class="">1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化
4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p></details></li></ul><ul id="61c972e4-3031-478f-926c-34e9e54c9a04" class="toggle"><li><details open=""><summary>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</summary><p id="6a1f8f30-1909-45bc-9bb5-5e333cfc97a7" class="">5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。
6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。
8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p></details></li></ul><ul id="978a2e79-81d7-44d2-9091-d1868721320a" class="toggle"><li><details open=""><summary>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝
注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</summary><p id="8d4d2c2c-3c92-4556-937e-43b6700d739b" class="">9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。
11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。
12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p></details></li></ul></details></li></ul><ul id="fdf5d086-b826-4250-8cb9-ea8b7c009383" class="toggle"><li><details open=""><summary>优点总结</summary><p id="a522b033-d694-4f7b-803e-bf7602036432" class="">1、对文件的读取操作跨过了页缓存，<mark class="highlight-red">减少了数据的拷贝次数</mark>，用内存读写取代I/O读写，提高了文件读取效率。</p><p id="828b326e-a7f3-44f2-a4c0-27483c217480" class="">2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p id="b691a67a-ae54-47c7-b318-63aee4cd82f9" class="">3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。<div class="indented"><p id="2b76846f-0e83-45c3-9971-2f0eb888c3c8" class="">如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p></div></p><p id="79b1bf52-8520-4484-949d-51593e1190f6" class="">4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p></details></li></ul><ul id="7e845ab6-43fd-4e62-895c-d1254c246f4e" class="toggle"><li><details open=""><summary><a href="https://blog.csdn.net/JMW1407/article/details/107703142">mmap API 函数讲解</a></summary></details></li></ul></details></li></ul></div><ul id="d6e963a9-d802-4a4b-95eb-c7eeea002ea2" class="toggle"><li><details open=""><summary>2 <a href="https://blog.csdn.net/JMW1407/article/details/107733056"><mark class="highlight-red">shmget</mark></a></summary><ul id="136a1a44-d485-4867-86cb-2c69d0967422" class="toggle"><li><details open=""><summary>图解总结</summary><figure id="c5c3fb6c-8031-469d-9da0-2d02ddb8b9c8" class="image"><a href="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2035.png"><img style="width:179px" src="%E8%BF%9B%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%2049528/Untitled%2035.png"/></a></figure></details></li></ul><ul id="839150ff-fea2-4bad-b81b-d85f272f1707" class="toggle"><li><details open=""><summary><mark class="highlight-red">创建</mark>共享内存shmget()</summary><p id="689adc68-05d9-480c-805e-add4636e5da4" class="">功能：（Shared Memory GET 获取共享内存）从内存中获取一块共享内存区域，该函数返回值为共享内存的ID</p><ul id="c074bbed-2753-4a26-a907-7f75f8fc3772" class="toggle"><li><details open=""><summary>shmget() 基本原理：</summary><p id="58140963-12fe-4f66-8e9e-17d9eb3db10f" class="">内核里存在着一个特殊的文件系统（shm），这个文件系统的存储介质不是别的，正是 RAM。</p><p id="b74a18e0-5085-4123-90c1-9f7035fcf7cd" class="">在 shmget() 调用之后，系统会为你在这个文件系统上创建一个文件，但是这个时候仅仅是创建了这个文件。</p></details></li></ul></details></li></ul><ul id="02b49869-c2a4-4b67-907d-774d6a2013b8" class="toggle"><li><details open=""><summary><mark class="highlight-red">映射</mark>共享内存shmat()</summary><p id="6de86a53-aa71-4014-af9b-9d75d0278b5c" class="">功能：（Shared Memory Attach 绑定到共享内存块）将上一步获取的共享内存映射到具体的内存空间。<div class="indented"><p id="ba25d471-e1dc-466c-ba14-25ec2c0197cb" class="">每个进程通过<mark class="highlight-red">shmat</mark>（Shared Memory Attach 绑定到共享内存块），将进程的逻辑虚拟地址空间指向共享内存块中。 随后需要访问这个共享内存块的进程都必须将这个共享内存绑定到自己的地址空间中去。当一个进程往一个共享内存快中写入了数据，共享这个内存区域的所有进程就可用都看到其中的内容。</p></div></p><ul id="b17b4a29-9cde-4d40-8c92-e7d60012b9f6" class="toggle"><li><details open=""><summary>shmget() 基本原理：</summary><p id="af742691-45a3-4830-8927-9ef77a95bcb2" class="">然后你就应该调用 shmat() （Shared Memory Attach 绑定到共享内存块）了，调用 shmat() 之后，内核会这个文件映射到你的进程地址空间，这个时候你就能直接读写映射后的地址了。</p></details></li></ul></details></li></ul><ul id="f2c06ac9-5b3a-45c9-a711-880bb14e712a" class="toggle"><li><details open=""><summary><mark class="highlight-red">释放</mark>共享内存shmdt()</summary><p id="3244b7a5-d8f0-422f-ae14-a0aa486ab31f" class="">功能：（Shared Memory Detach，脱离共享内存块）</p><ul id="edea5670-e168-4342-a078-0d62cb74f933" class="toggle"><li><details open=""><summary>shmget() 基本原理：</summary><p id="a8fbf8cb-f723-408f-9caa-ec833d1fe43c" class="">当一个进程不再使用一个共享内存块的时候应通过调用<mark class="highlight-red"> shmdt</mark>函数与该共享内存块脱离。如果<mark class="highlight-red">当释放这个内存块的进程是最后一个使用该内存块的进程，则这个内存块将被删除</mark>。对 exit 或任何exec族函数的调用都会自动使进程脱离共享内存块。</p></details></li></ul><p id="30dd2d24-c5e4-4baa-95d5-1c9d5e2de4ff" class="">
</p></details></li></ul><p id="f587f6ee-d774-4546-b68f-d046a2f264cb" class="">
</p></details></li></ul><ul id="bbbce340-e4d8-4513-8d6c-f91731966458" class="toggle"><li><details open=""><summary>两者区别</summary><ul id="2e170723-4896-486c-9fe3-eb7e5fba9501" class="toggle"><li><details open=""><summary>1、mmap()通过映射一个普通文件实现共享内存，shmget()：内核里存在着一个特殊的文件系统（shm），这个文件系统的存储介质不是别的，正是 RAM。</summary><p id="324ae494-8b72-4407-9646-809f4b74e210" class="">所以，mmap可以看到文件的实体，而 shmget 对应的文件在交换分区上的 shm 文件系统内，无法直接 cat 查看
速度比较：shm保存在RAM，这样读写的速度要比磁盘要快，但是存储量不是特别大。mmap是在磁盘上建立一个文件
安全比较： mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失。</p></details></li></ul><ul id="694a05bd-1800-4c91-88ad-3b3792f9399c" class="toggle"><li><details open=""><summary>2、mmap是在磁盘上建立一个文件，每个进程地址空间中都会开辟出一块空间进行文件-内存的映射。
而对于shm而言，shm每个进程最终会映射到同一块物理内存。
mmap 方式下各进程映射文件的相同部分可以共享内存， shmget 时各个进程共享同一片物理内存区</summary></details></li></ul></details></li></ul><p id="b54af7f8-84fc-42ff-9124-57858a4b43e2" class="">
</p><p id="89938fe8-a9c2-4646-9c6b-b79cacf87af5" class="">
</p></details></li></ul><ul id="6cdcafb6-7075-4b3e-b541-f173a2a507e3" class="toggle"><li><details open=""><summary><a href="http://c.biancheng.net/view/1208.html">优缺点</a></summary><p id="26eb56e2-d847-44be-ac41-3244cff33a0b" class="">共享内存可以快于消息传递，这是因为消息队列的实现经常采用系统调用，因此需要消耗更多时间以便内核介入。</p><p id="ad186158-412a-4572-8703-6de1785942cc" class="">共享内存系统仅在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。</p></details></li></ul><ul id="9195120d-abc2-48fa-b04d-de2964a4abb5" class="toggle"><li><details open=""><summary>模型：<a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">生产者-消费者问题</a></summary><ul id="3dd5cad2-4902-4889-89f4-15769fd20997" class="toggle"><li><details open=""><summary>解决生产者-消费者问题的方法之一是采用共享内存。为了允许生产者进程和消费者进程并发执行，应有一个可用的缓冲区，以被生产者填充和被消费者清空。这个缓冲区驻留在生产者进程和消费者进程的共享内存区域内。当消费者使用一项时，生产者可产生另一项。生产者和消费者必须同步，这样消费者不会试图消费一个尚未生产出来的项。</summary></details></li></ul><p id="0c00e9f1-8e1a-4c50-a345-847398dc3354" class="">缓冲区类型可分两种：</p><ul id="cd797ec6-16b7-4005-8b86-0a08e9ec9373" class="bulleted-list"><li style="list-style-type:disc">无界缓冲区没有限制缓冲区的大小。消费者可能不得不等待新的项，但生产者总是可以产生新项。</li></ul><ul id="017aa469-a015-4005-beb5-506625929e8a" class="bulleted-list"><li style="list-style-type:disc">有界缓冲区假设固定大小的缓冲区。对于这种情况，如果缓冲区空，那么消费者必须等待；并且如果缓冲区满，那么生产者必须等待。</li></ul></details></li></ul></details></li></ul><ul id="95def116-c0ab-4b30-8c24-98315b1824fd" class="toggle"><li><details open=""><summary>三者总结</summary><ul id="4645e92b-b6fe-4391-aa85-ab8965b68d23" class="toggle"><li><details open=""><summary>管道和消息队列区别：</summary><ul id="2baa9e91-3815-4616-ba6e-15a23d3e1d64" class="toggle"><li><details open=""><summary>1 生命周期</summary><p id="66354627-eb3d-4700-80f5-f270f65032c4" class="">匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁</p><p id="a76b8e2c-e347-4182-b88d-d133f6d37cb4" class="">消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</p></details></li></ul><ul id="00d688b3-791c-4de3-9460-af93e880038f" class="toggle"><li><details open=""><summary>2 存储方式</summary><ul id="9b79021a-63c7-43d6-9176-9c2a96a88924" class="toggle"><li><details open=""><summary>消息队列是保存在内核中的消息链表，</summary></details></li></ul><ul id="37d421bf-914a-4666-997a-6b865e830684" class="toggle"><li><details open=""><summary>管道是无格式的字节流数据</summary></details></li></ul></details></li></ul></details></li></ul><table id="1a7ad325-34ec-4662-8ae6-8b5486feb888" class="simple-table"><tbody><tr id="5f511d07-d35b-45dc-88a4-6c022bcde0ae"><td id="]THu"></td><td id=":UZU">管道</td><td id="t^~E"><mark class="highlight-red">消息队列</mark></td><td id="oe}:"><mark class="highlight-red">共享内存</mark></td></tr><tr id="e6eaace7-5424-4499-949a-8519021501ac"><td id="]THu">定义</td><td id=":UZU"></td><td id="t^~E"></td><td id="oe}:"></td></tr><tr id="8d86dcf3-8112-4eb3-94d8-ad762bac03b6"><td id="]THu">数据形态</td><td id=":UZU">无格式的字节流数据</td><td id="t^~E">消息队列是保存在内核中的消息链表
消息体是固定大小的存储块</td><td id="oe}:">直接数据</td></tr><tr id="ae55e3a5-f1f4-4429-9f15-e4e2a59152af"><td id="]THu">内存中位置</td><td id=":UZU">内核</td><td id="t^~E">内核</td><td id="oe}:">文件 或者 RAM</td></tr><tr id="fe0e7d1e-eab5-4290-9d89-2b75d49f1db4"><td id="]THu">效率</td><td id=":UZU">最慢</td><td id="t^~E"></td><td id="oe}:">高</td></tr></tbody></table></details></li></ul><p id="ca2f57d4-8f3c-4070-b383-2a7c093fa7a6" class="">
</p><ul id="a560e12e-7fff-4c96-b343-1eb63d47ebde" class="toggle"><li><details open=""><summary>信号</summary><ul id="167b01bb-7de6-4945-a454-f6b65bb02ef6" class="toggle"><li><details open=""><summary>上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</summary></details></li></ul><ul id="f2a0ce51-d634-4de8-b6f6-34988b3eecc9" class="toggle"><li><details open=""><summary>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l </code>命令，查看所有的信号：</summary></details></li></ul><ul id="253fc49d-004c-4781-8e68-c4b3644ed347" class="toggle"><li><details open=""><summary>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</summary><ul id="0d5c1420-5fe4-494a-91ea-8a0a7df40f2e" class="bulleted-list"><li style="list-style-type:disc">Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li></ul><ul id="2676f4f9-4965-401f-890e-5808c4e312fc" class="bulleted-list"><li style="list-style-type:disc">Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p id="5ba9daac-5579-48a6-a3f5-f4e345dbab81" class="">如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul id="ba72f86f-d4c8-42b7-bdd2-d8946f160136" class="bulleted-list"><li style="list-style-type:disc"><code>kill</code>：<code>kill -9 1050</code> ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程；</li></ul></details></li></ul><ul id="5d34531f-0762-4a9c-bbde-38660c10eada" class="toggle"><li><details open=""><summary>所以，信号事件的<mark class="highlight-red">来源主要有硬件</mark>来源（如键盘 Cltr+C ）和<mark class="highlight-red">软件</mark>来源（如 kill 命令）。</summary></details></li></ul><ul id="3224a464-1f91-4975-8fd5-228f73011030" class="toggle"><li><details open=""><summary>信号是进程间通信机制中<mark class="highlight-red"><strong>唯一的异步通信机制</strong></mark>，因为<mark class="highlight-red">可以在任何时候发送信号给某一进程</mark>，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</summary><p id="7cc2ad90-4255-4404-803f-4ffe57e214dc" class=""><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p><p id="5f135305-b6d2-4ea6-9f90-f9bb238f83e6" class=""><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p id="023e48b1-47ca-44d4-8f6d-10a0b604e978" class=""><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></details></li></ul><p id="7d971b7a-acc3-43ef-b3bc-c85821bd412d" class="">
</p></details></li></ul><ul id="db4fcce4-f94d-44c2-a05a-71e13e6aff8b" class="toggle"><li><details open=""><summary><a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">socket</a></summary><p id="cb57ce52-e649-4242-8f7c-7fb6f5f72ad6" class="">套接字通信并不为Linux所专有，在所有提供了TCP/IP协议栈的操作系统中几乎都提供了socket，而所有这样操作系统，对套接字的编程方法几乎是完全一样的</p><p id="68b977ab-0b0c-4f1b-93ce-40c8546d1eed" class="">前面都是同一台主机，Socket 通信不仅可以跨网络与<mark class="highlight-red">不同主机的进程间通信</mark>，还可以在<mark class="highlight-red">同主机</mark>上进程间通信。我们来看看创建 socket 的系统调用：</p><pre id="a95a367f-5191-461f-bf6b-9228fba16d42" class="code code-wrap"><code>int socket(int domain, int type, int protocal)</code></pre><ul id="36b6ab5f-a02f-433d-8a7e-949180e20316" class="toggle"><li><details open=""><summary>三个参数分别代表：</summary><ul id="9d4f782a-09c4-44e9-8cad-dae7019290c4" class="bulleted-list"><li style="list-style-type:disc">domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；</li></ul><ul id="719cc335-73da-4e31-9e61-e570148248a5" class="bulleted-list"><li style="list-style-type:disc">type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li></ul><ul id="b5d53fc7-4441-4a20-8793-209584ea34f3" class="bulleted-list"><li style="list-style-type:disc">protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul></details></li></ul><ul id="7f35adfa-4c9d-4a05-bc26-d988e6256c25" class="toggle"><li><details open=""><summary>根据创建 socket 类型的不同，通信的方式也就不同：</summary><ul id="ca1ee689-5776-4ea7-b56d-b51b31b6e3b7" class="bulleted-list"><li style="list-style-type:disc">实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li></ul><ul id="75aad43c-d884-4ef2-8108-f2c3771e3b80" class="bulleted-list"><li style="list-style-type:disc">实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li></ul><ul id="b22c5523-f156-4221-89ca-415030c8eb67" class="bulleted-list"><li style="list-style-type:disc">实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul></details></li></ul><p id="7372cf0d-c68a-4dca-ac4c-1b3e2dc71386" class="">接下来，简单说一下这三种通信的编程模式。</p><ul id="66b3daf2-fa5e-427d-b38e-c2de045b3357" class="toggle"><li><details open=""><summary>针对 TCP 协议通信的 socket 编程模型</summary><ul id="0f6b7aa7-9a62-4c58-a23e-e5b12854c9b8" class="toggle"><li><details open=""><summary>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</summary></details></li></ul><ul id="1ff5f8b6-85d9-4ed4-bb38-9549a46b32dc" class="toggle"><li><details open=""><summary>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</summary></details></li></ul><ul id="7d4bc118-64fa-4b01-ae53-9b5f9c61e5b6" class="toggle"><li><details open=""><summary>服务端调用 <code>listen</code>，进行监听；</summary></details></li></ul><ul id="e0591367-ae64-498c-ae74-c42a177b2e43" class="toggle"><li><details open=""><summary>服务端调用 <code>accept</code>，等待客户端连接；</summary><p id="18e0d9ca-d04e-4bf4-ba53-0a8e9e322c8d" class="">这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p></details></li></ul><ul id="453733e8-e395-498b-8dd1-581c2799b61a" class="toggle"><li><details open=""><summary>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</summary></details></li></ul><ul id="9dd66370-63a3-494b-9bc5-9a7e2c8aad5a" class="toggle"><li><details open=""><summary>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</summary></details></li></ul><ul id="8af93d6b-4b9f-41f6-9546-bdb93d730df7" class="toggle"><li><details open=""><summary>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</summary></details></li></ul><ul id="1f8d6ce3-dd97-49dc-8a92-008368bde0cc" class="toggle"><li><details open=""><summary>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</summary></details></li></ul><p id="ac505cff-3325-4d79-8643-4f06e0738b86" class="">所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p id="a28ebbc1-81a3-4ba9-be15-a351a7debc23" class="">成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><figure id="fe87a0d4-efa4-45da-8df6-e5f78bce7884" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iMDU3MmRkOS03YTI1LTQ0OTUtOWIyZS0wZTg1NjM0MTg1ZTMucG5n?x-oss-process=image/format,png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9iMDU3MmRkOS03YTI1LTQ0OTUtOWIyZS0wZTg1NjM0MTg1ZTMucG5n?x-oss-process=image/format,png"/></a></figure></details></li></ul><ul id="91735f7a-b428-4f46-805d-5d695c2f8a9a" class="toggle"><li><details open=""><summary>针对 UDP 协议通信的 socket 编程模型</summary><figure id="ffd0b20a-97c6-47ba-9033-6cd414243902" class="image"><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82NTRjY2Y3NC02MWJkLTQ3OTItYWNlZi1jYWI3ZWUwZGM5YzkucG5n?x-oss-process=image/format,png"><img style="width:384px" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82NTRjY2Y3NC02MWJkLTQ3OTItYWNlZi1jYWI3ZWUwZGM5YzkucG5n?x-oss-process=image/format,png"/></a></figure><p id="bd5190b0-9062-4db8-b0c3-c2d193005349" class="">UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p id="15187258-0bce-44ba-a530-d38e5944e330" class="">对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p id="e21ae418-06db-45be-a744-9faaae3e8edc" class="">另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p></details></li></ul><ul id="1fafba8c-c54a-4762-ac77-de8873174826" class="toggle"><li><details open=""><summary>针对本地进程间通信的 socket 编程模型</summary><p id="3b69d1c5-3231-4ff5-a357-2af2c118f2fd" class="">本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul id="ba89e3b3-4163-4f3e-938c-8be6ef1b3433" class="bulleted-list"><li style="list-style-type:disc">本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li></ul><ul id="ae8c902d-71a9-46a2-a21b-11a75fe72321" class="bulleted-list"><li style="list-style-type:disc">本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p id="3b7daab8-5fb2-48af-9c03-32115d26e006" class="">对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p id="3ad44126-a03e-4ad5-8d99-051cd9ab4df6" class="">对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p id="e5161baa-8764-4711-bc08-312f7b15bca8" class="">本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p></details></li></ul></details></li></ul></details></li></ul><p id="937dbf23-d5be-4695-86b9-0562e33406d0" class="">
</p><ul id="2a098ec4-d097-4b3f-bdb5-067ec153eb5e" class="toggle"><li><details open=""><summary>ref：</summary><p id="e7c6a2d1-e042-4b29-8384-e6641536c039" class=""><a href="https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html">ref1 </a>,  <a href="https://blog.csdn.net/J080624/article/details/87454764">参考2</a>   <a href="https://www.notion.so/OS-Linux-socket-851919365453451c9cd9ca4a3e45b1d2">同步&amp;互斥</a></p><figure id="484880ea-15f5-4c53-8f03-11ac0ccd2f9f"><a href="https://www.cnblogs.com/xiaolincoding/p/13402297.html" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">凉了！张三同学没答好「进程间通信」，被面试官挂了....</div><div class="bookmark-description">炎炎夏日，张三骑着单车去面试花了 1 小时，一路上汗流浃背。 结果面试过程只花了 5 分钟就结束了，面完的时候，天还是依然是亮的，还得在烈日下奔波 1 小时回去。 面试五分钟，骑车两小时。 你看，张三因面试没准备好，吹空调的时间只有 5 分钟，来回路上花了 2 小时晒太阳，你说惨不惨？ 所以啊，炎炎夏日，为了能延长吹空调的时间，我们应该在面试前准备得更充分些，吹空调时间是要自己争取的。 很明显，在这一场面试中， 张三在 进程间通信这一块没复习好，虽然列出了进程间通信的方式，但这只是表面功夫， 应该需要进一步了解每种通信方式的优缺点及应用场景。 说真的，我们这次一起帮张三一起复习下，加深他对进程间通信的理解，好让他下次吹空调的时间能长一点。 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。 Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？ 如果你学过 Linux 命令，那你肯定很熟悉「| 」这个竖线。 上面命令行里的「|」竖线就是一个 管道，它的功能是将前一个命令（ ps auxf）的输出，作为后一个命令（ grep mysql）的输入，从这功能描述，可以看出 管道传输数据是单向的 ，如果想相互通信，我们需要创建两个管道才行。 同时，我们得知上面这种管道是没有名字，所以「|」表示的管道称为 匿名管道 ，用完了就销毁。 管道还有另外一个类型是 命名管道，也被叫做 FIFO ，因为数据是先进先出的传输方式。 在使用命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字： myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思： $ ls -lprw-r--r--.</div></div><div class="bookmark-href"><img src="https://www.cnblogs.com/favicon.ico" class="icon bookmark-icon"/>https://www.cnblogs.com/xiaolincoding/p/13402297.html</div></div></a></figure><figure id="2931b3f2-b19f-44fc-b23a-68263c5628c4"><a href="https://icevil.cn/2020/03/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">进程间通信与线程同步</div><div class="bookmark-description">进程通信(Interprocess Communication，IPC)是一个进程与另一个进程间进程间传输数据或交换信息。目的是提高系统扩展功能的同时，以内存安全访问的形势提升的并行性能。 管道是Linux/Windows（winCE不支持）都具有的进程间通信方式，它是一种半双工的通信方式，数据只能单向流动，且具有FIFO特性。分命名管道与匿名管道两种，管道默认指匿名管道。 ...</div></div><div class="bookmark-href"><img src="https://icevil.cn/uploads/favicon-16x16-next.png" class="icon bookmark-icon"/>https://icevil.cn/2020/03/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</div></div><img src="https://icevil.cn/uploads/avatar.jpg" class="bookmark-image"/></a></figure></details></li></ul><p id="0f9252ad-e80d-4c0b-9bfe-403e658045a5" class="">
</p></div></article></body></html>